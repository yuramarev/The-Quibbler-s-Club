<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hogwarts House Cup Tracker</title>
    <!-- Lightning Bolt Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>‚ö°</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Cinzel+Decorative:wght@400;700&family=MedievalSharp&family=IM+Fell+English&family=Merriweather&family=Lora&family=Playfair+Display&family=EB+Garamond&family=Roboto+Slab&family=Lato&family=Open+Sans&family=Cormorant+Garamond&family=Alegreya&family=Uncial+Antiqua&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <style>
        body { 
            font-family: 'Inter', sans-serif;
            overflow-x: hidden; /* Prevent horizontal scrollbar from canvas */
        }
        /* Animated Background Canvas */
        #animated-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Place it behind all other content */
        }
        .font-magic-title { font-family: 'Cinzel Decorative', cursive; }
        .font-magic-header { font-family: 'MedievalSharp', cursive; }
        ::-webkit-scrollbar { width: 12px; }
        ::-webkit-scrollbar-track { background: #1A2B3C; }
        ::-webkit-scrollbar-thumb { background-color: #3D5568; border-radius: 20px; border: 3px solid #1A2B3C; }
        ::-webkit-scrollbar-thumb:hover { background-color: #FFD700; }
        .progress-bar { background-color: #2A3B4D; border-radius: 9999px; overflow: hidden; border: 1px solid #4A5B6D; }
        .progress-bar-inner { height: 100%; border-radius: 9999px; transition: width 0.5s ease-in-out, background-color 0.5s ease-in-out; text-align: center; color: white; font-weight: bold; }
        .modal-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.7); display: flex; justify-content: center; align-items: center; z-index: 1000; opacity: 0; visibility: hidden; transition: opacity 0.3s, visibility 0.3s; }
        .modal-backdrop.show { opacity: 1; visibility: visible; }
        .modal-content { 
            position: relative; 
            background-color: #1A2B3C; 
            padding: 2rem; 
            border-radius: 0.5rem; 
            border: 1px solid #FFD700; 
            width: 90%; 
            max-width: 500px; 
            max-height: 90vh; 
            overflow-y: auto; 
            transform: scale(0.9); 
            transition: transform 0.3s; 
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3); /* Enhanced border glow */
        }
        .modal-backdrop.show .modal-content { transform: scale(1); }
        
        /* Close button for modals - ENHANCED */
        .modal-close-btn {
            position: sticky; /* Stick to the top of the scrolling container */
            top: -1rem; /* Adjust position relative to padding */
            right: -1rem;
            float: right; /* Keep it aligned to the right */
            font-size: 2rem;
            color: #9CA3AF; /* gray-400 */
            cursor: pointer;
            transition: color 0.2s;
            line-height: 1;
            z-index: 1010; /* Ensure it's above modal content */
            background: #1A2B3C; /* Match modal background */
            padding: 0.5rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: -1rem -1rem 0 0; /* Adjust for padding */
        }
        .modal-close-btn:hover { color: #FFFFFF; }

        #definition-popup-modal { z-index: 2500; } /* Ensure definition popup is on top of reading mode */
        .btn { padding: 0.5rem 1rem; border-radius: 0.375rem; font-weight: 600; transition: all 0.2s; border: 1px solid transparent; cursor: pointer; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; box-shadow: none; }
        .btn-gold { background-color: #FFD700; color: #1A2B3C; border-color: #FFC700; }
        .btn-gold:hover:not(:disabled) { background-color: #F0C40F; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(255, 215, 0, 0.2); }
        .btn-destructive { background-color: #AE0001; color: white; border-color: #8E0001; }
        .btn-destructive:hover:not(:disabled) { background-color: #8E0001; transform: translateY(-2px); box-shadow: 0 4px 8px rgba(174, 0, 1, 0.2); }
        #duel-arena { background-image: url('https://www.transparenttextures.com/patterns/dark-matter.png'); border: 2px solid #FFD700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.3); }
        .duelist-panel { transition: all 0.3s ease-in-out; }
        .duelist-panel.active-turn { transform: scale(1.05); box-shadow: 0 0 15px rgba(255, 255, 255, 0.5); }
        .spell-effect { position: absolute; font-size: 2rem; opacity: 0; animation: shootSpell 1.5s ease-out forwards; pointer-events: none; }
        @keyframes shootSpell { 0% { transform: translateY(0) scale(0.5); opacity: 1; } 100% { transform: translateY(-500px) scale(1.5); opacity: 0; } }
        
        /* D20 Dice Styles */
        #d20-dice { width: 100px; height: 100px; perspective: 1000px; margin: 20px auto; }
        #d20-cube { width: 100%; height: 100%; position: relative; transform-style: preserve-3d; transition: transform 1s; }
        .d20-face { position: absolute; width: 100px; height: 100px; border: 2px solid #FFD700; background: rgba(12, 28, 51, 0.8); color: #FFD700; font-size: 48px; font-weight: bold; display: flex; justify-content: center; align-items: center; }
        .d20-face.success { background: rgba(42, 98, 61, 0.8); border-color: #34D399; }
        .d20-face.failure { background: rgba(174, 0, 1, 0.8); border-color: #F87171; }
        .d20-face.crit-fail { background: rgba(100, 0, 100, 0.9); border-color: #f0f; box-shadow: 0 0 15px #f0f; }
        .d20-face.crit-success { background: rgba(255, 215, 0, 0.8); border-color: #fff; color: #0C1C33; box-shadow: 0 0 15px #FFD700; }
        @keyframes roll-dice {
            0% { transform: rotateX(0deg) rotateY(0deg); }
            100% { transform: rotateX(1080deg) rotateY(1080deg); }
        }
        .rolling { animation: roll-dice 1s ease-out; }
        
        /* Style for learning words */
        .learn-word { color: #8ab4f8; font-weight: bold; cursor: pointer; }
        .clickable-word { color: #4a5568; font-weight: bold; cursor: pointer; transition: color 0.2s; }
        .clickable-word:hover { color: #2c3e50; }


        /* Disabled Admin Controls Style */
        .admin-controls-disabled {
            opacity: 0.6;
            position: relative;
            pointer-events: none; /* Block clicks on the container */
        }
        .admin-controls-disabled button {
            cursor: not-allowed !important; /* Force cursor change */
        }
        
        /* Reader Styles - Parchment Effect */
        .parchment {
            background-color: #fdf5e6; /* Parchment color */
            color: #5a4429; /* Dark brown text */
            font-family: 'IM Fell English', serif;
            border: 1px solid #d3c0a5;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            background-image: url('https://www.transparenttextures.com/patterns/old-paper.png'); /* Subtle texture */
        }
        .parchment h4 {
            font-family: 'MedievalSharp', cursive;
            color: #8B4513; /* SaddleBrown */
            text-align: center;
            border-bottom: 2px solid #d3c0a5;
            padding-bottom: 0.5rem;
            font-size: 1.5rem;
        }
        .parchment p {
            text-indent: 2em; /* Indent first line of paragraphs */
            margin-bottom: 1em;
            line-height: 1.8;
            font-size: 1.1rem;
            text-align: justify; /* Justify text for a book-like feel */
        }
        #reader-content-container.parchment::-webkit-scrollbar-track { background: #eaddc9; }
        #reader-content-container.parchment::-webkit-scrollbar-thumb { background-color: #bcae98; border: 3px solid #eaddc9; }

        /* Style for editable fields */
        [contenteditable="true"] {
            outline: 2px dashed #FFD700;
            background-color: rgba(255, 248, 225, 0.2);
            padding: 2px 4px;
            border-radius: 4px;
            color: #FFD700;
        }
        
        /* Library Styles */
        .book-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid #3D5568;
        }
        .book-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2);
            border-color: #FFD700;
        }
        .chapter-item {
            transition: background-color 0.2s, color 0.2s;
        }
        .chapter-item:hover {
            background-color: #2A3B4D;
        }
        .chapter-item.active {
            background-color: #1e3a5f;
            color: white;
            border-left: 3px solid #5dade2;
        }
        .reader-toolbar {
            background-color: #1A2B3C;
            border-radius: 8px;
            border: 1px solid #3D5568;
        }
        .toolbar-btn {
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            background-color: #2A3B4D;
            color: #E0E0E0;
            transition: all 0.2s;
        }
        .toolbar-btn:hover {
            background-color: #3D5568;
            transform: translateY(-1px);
        }
        .font-option {
            font-family: inherit;
        }
        .reading-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2000;
            background: #e9e2d6; /* A slightly darker background for contrast */
            padding: 1rem;
            display: flex;
            gap: 1rem;
        }
        .reading-mode-main {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .reading-mode .parchment {
            height: 100%;
            width: 100%;
            flex-grow: 1;
        }
        .reading-mode-dictionary {
            flex-shrink: 0;
            width: 320px;
            height: 100%;
            display: flex;
            flex-direction: column;
            background-color: #fdf5e6;
            border-left: 2px solid #d3c0a5;
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
        }
        .reading-mode-toolbar {
            position: fixed;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2010;
        }
        
        /* Base Dictionary Styles */
        .dictionary-word-card {
            background-color: #0C1C33;
            border: 1px solid #3D5568;
            transition: all 0.2s ease-in-out;
        }
        .dictionary-word-card:hover {
            border-color: #FFD700;
            transform: translateY(-2px);
        }

        /* New Dictionary Styles for Reading Mode */
        .reading-mode-dictionary .dictionary-word-card {
            background-color: #f4eadb; /* Lighter parchment */
            border: 1px solid #d3c0a5; /* Parchment border color */
            box-shadow: 1px 1px 3px rgba(0,0,0,0.1);
        }
        .reading-mode-dictionary .dictionary-word-card:hover {
            transform: none;
            border-color: #bcae98;
        }
        .reading-mode-dictionary .dictionary-word-card h4 {
            color: #8B4513; /* SaddleBrown, like the headers */
        }
        .reading-mode-dictionary .dictionary-word-card p {
            color: #5a4429; /* Dark brown text */
        }
        .reading-mode-dictionary .dictionary-word-card .btn {
            font-family: 'Inter', sans-serif;
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            transform: none !important;
            box-shadow: none !important;
        }
        .reading-mode-dictionary .dictionary-word-card .btn.bg-blue-600 {
            background-color: #d3c0a5;
            color: #5a4429;
            border: 1px solid #bcae98;
        }
        .reading-mode-dictionary .dictionary-word-card .btn.bg-blue-600:hover:not(:disabled) {
             background-color: #bcae98;
        }
        .reading-mode-dictionary .dictionary-word-card .btn.btn-destructive {
            background-color: #d3b5b5;
            color: #5a2929;
            border: 1px solid #a18080;
        }
         .reading-mode-dictionary .dictionary-word-card .btn.btn-destructive:hover:not(:disabled) {
            background-color: #c8a1a1;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-left-color: #FFD700;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .notification-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background-color: #AE0001;
            color: white;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            border: 1px solid white;
        }
        
        /* Quidditch Styles */
        .quidditch-chat-message {
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-bottom: 0.75rem;
            max-width: 90%;
        }
        .quidditch-chat-message.user-message {
            background-color: #2B4C7E; /* Ravenclaw Blue */
            align-self: flex-end;
            text-align: right;
        }
        .quidditch-chat-message.ai-message {
            background-color: #2A3B4D;
            align-self: flex-start;
        }
        .quidditch-chat-message.event-message {
            background-color: transparent;
            color: #FFD700;
            font-style: italic;
            text-align: center;
            align-self: center;
            width: 100%;
        }
        #quidditch-dice-container {
            perspective: 600px;
        }
        #quidditch-dice {
            width: 60px;
            height: 60px;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 1s ease-out;
        }
        #quidditch-dice.rolling {
            animation: quidditch-roll 1s ease-out;
        }
        @keyframes quidditch-roll {
            from { transform: rotateX(0deg) rotateY(0deg); }
            to   { transform: rotateX(720deg) rotateY(720deg); }
        }
        .quidditch-dice-face {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid #FFD700;
            color: #FFD700;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Glow effects */
        .glow {
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            from { box-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #FFD700, 0 0 20px #FFD700; }
            to { box-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #FFD700, 0 0 40px #FFD700; }
        }
        
        /* Dictionary Training Styles */
        .training-hub-card {
            background-color: #0C1C33;
            border: 1px solid #3D5568;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        .training-hub-card:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: #FFD700;
            box-shadow: 0 8px 15px rgba(0,0,0,0.3);
        }
        .training-game-option {
            transition: all 0.2s ease;
            border: 2px solid #3D5568;
        }
        .training-game-option:hover:not(:disabled) {
            border-color: #FFD700;
            background-color: #2A3B4D;
        }
        .training-game-option.correct {
            background-color: #2A623D !important;
            border-color: #34D399 !important;
            transform: scale(1.05);
        }
        .training-game-option.incorrect {
            background-color: #AE0001 !important;
            border-color: #F87171 !important;
            opacity: 0.7;
        }
        .letter-tile {
            transition: all 0.2s ease;
            cursor: pointer;
            user-select: none;
        }
        .letter-tile:hover {
            background-color: #FFD700;
            color: #0C1C33;
        }
        .word-card {
            perspective: 1000px;
            cursor: pointer;
        }
        .word-card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        }
        .word-card.is-flipped .word-card-inner {
            transform: rotateY(180deg);
        }
        .word-card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 2px solid #FFD700;
        }
        .word-card-front {
            background-color: #2A3B4D;
        }
        .word-card-back {
            background-color: #0C1C33;
            transform: rotateY(180deg);
        }
    </style>
</head>
<body class="bg-[#0C1C33] text-[#E0E0E0]">

    <!-- Animated Background -->
    <canvas id="animated-bg"></canvas>

    <!-- Authentication Container -->
    <div id="auth-container" class="min-h-screen flex items-center justify-center">
        <div class="bg-[#1A2B3C] p-8 rounded-lg shadow-lg w-full max-w-md border-t-4 border-[#FFD700]">
            <h2 class="font-magic-title text-3xl text-center text-[#FFD700] mb-6">Hogwarts Login</h2>
            
            <!-- Login Form -->
            <form id="login-form">
                <div class="mb-4">
                    <label for="login-email" class="block mb-2 text-sm font-medium text-gray-300">Email</label>
                    <input type="email" id="login-email" name="email" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568] focus:ring-[#FFD700] focus:border-[#FFD700]" required>
                </div>
                <div class="mb-6">
                    <label for="login-password" class="block mb-2 text-sm font-medium text-gray-300">Password</label>
                    <input type="password" id="login-password" name="password" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568] focus:ring-[#FFD700] focus:border-[#FFD700]" required>
                </div>
                <button type="submit" class="btn btn-gold w-full">Login</button>
            </form>

            <!-- Registration Form -->
            <form id="register-form" style="display: none;">
                <div class="mb-4">
                    <label for="register-email" class="block mb-2 text-sm font-medium text-gray-300">Email</label>
                    <input type="email" id="register-email" name="email" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568] focus:ring-[#FFD700] focus:border-[#FFD700]" required>
                </div>
                <div class="mb-4">
                    <label for="register-password" class="block mb-2 text-sm font-medium text-gray-300">Password (min. 6 characters)</label>
                    <input type="password" id="register-password" name="password" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568] focus:ring-[#FFD700] focus:border-[#FFD700]" required>
                </div>
                <div class="mb-6">
                    <label for="register-password-confirm" class="block mb-2 text-sm font-medium text-gray-300">Confirm Password</label>
                    <input type="password" id="register-password-confirm" name="passwordConfirm" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568] focus:ring-[#FFD700] focus:border-[#FFD700]" required>
                </div>
                <button type="submit" class="btn btn-gold w-full">Register</button>
            </form>

            <p id="auth-error" class="text-red-500 text-center mt-4"></p>

            <div class="text-center mt-4">
                <a href="#" id="show-register" class="text-sm text-[#FFD700] hover:underline">No account? Register here</a>
                <a href="#" id="show-login" class="text-sm text-[#FFD700] hover:underline" style="display: none;">Already have an account? Login</a>
            </div>
        </div>
    </div>

    <!-- Main Application Container (hidden by default) -->
    <div id="app-container" class="p-4 md:p-8 max-w-7xl mx-auto" style="display: none;">
        
        <!-- Header -->
        <header class="bg-[#1A2B3C] p-4 rounded-lg shadow-lg mb-8 flex flex-col md:flex-row justify-between items-center border-b-2 border-[#FFD700] glow">
            <div class="flex items-center gap-4 mb-4 md:mb-0">
                <!-- Logo Uploader -->
                <div class="relative group cursor-pointer">
                    <img id="school-logo" src="https://placehold.co/80x80/0C1C33/FFD700?text=LOGO" alt="School Logo" class="w-16 h-16 md:w-20 md:h-20 rounded-full border-2 border-[#FFD700] object-cover transition-opacity group-hover:opacity-70">
                    <div class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                        <span class="text-white text-xs md:text-sm font-bold">Change</span>
                    </div>
                </div>
                <input type="file" id="logo-upload" class="hidden" accept="image/*">

                <div>
                    <h1 class="text-2xl md:text-3xl font-magic-title text-[#FFD700]">Hogwarts Tracker</h1>
                    <p id="app-version" class="text-sm text-[#C0C0C0]"></p>
                </div>
            </div>
            <div class="flex flex-wrap gap-2 justify-center items-center">
                 <div class="text-sm text-gray-300">
                    User: <span id="user-display" class="font-bold text-white"></span>
                    <button id="change-password-btn" class="ml-2 text-xs text-[#FFD700] hover:underline focus:outline-none">(change password)</button>
                 </div>
                <button id="quidditch-btn" class="btn btn-gold">‚ö° Quidditch</button>
                <button id="dictionary-training-btn" class="btn btn-gold">üß† Train Words</button>
                <button id="dictionary-btn" class="btn btn-gold">üìñ Dictionary</button>
                <button id="library-btn" class="btn btn-gold">üìö Library</button>
                <button id="questions-btn" class="btn btn-gold">‚ùì Questions</button>
                <button id="magic-shop-btn" class="btn btn-gold">üõçÔ∏è Magic Shop</button>
                <button id="dueling-club-btn" class="btn btn-gold">‚öîÔ∏è Dueling Club</button>
                <button id="cast-spell-btn" class="btn btn-gold" disabled>üîÆ Cast Spell</button>
                <button id="logout-btn" class="btn btn-destructive">Logout</button>
            </div>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-3 gap-8">
            <!-- Left Column: Houses and Actions -->
            <div class="lg:col-span-1 space-y-8">
                <!-- House Points -->
                <section class="bg-[#1A2B3C] p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-magic-header text-center text-[#FFD700] mb-6">House Cup Standings</h2>
                    <div id="house-points-container">
                        <!-- Dynamic house insertion -->
                    </div>
                </section>

                <!-- Admin Controls -->
                <section id="admin-controls" class="bg-[#1A2B3C] p-6 rounded-lg shadow-lg">
                    <h2 class="text-2xl font-magic-header text-center text-[#FFD700] mb-6">Control Panel</h2>
                    <div class="grid grid-cols-2 gap-4">
                        <button id="award-points-btn" class="btn btn-gold col-span-2">üèÜ Award/Deduct Points</button>
                        <button id="award-achievement-btn" class="btn btn-gold col-span-2">üåü Grant Achievement</button>
                        <div class="relative col-span-2">
                            <button id="potion-requests-btn" class="btn btn-gold w-full">üß™ Potion Requests</button>
                            <span id="potion-requests-badge" class="notification-badge hidden">0</span>
                        </div>
                        <button id="assign-houses-btn" class="btn btn-gold col-span-2">üé© Sort Students</button>
                        <button id="manage-groups-btn" class="btn btn-gold col-span-2">üë• Manage Groups</button>
                        <button id="edit-students-btn" class="btn btn-gold col-span-2">‚ûï Manage Students</button>
                        <button id="link-accounts-btn" class="btn btn-gold col-span-2">üîó Link Accounts</button>
                        <button id="random-event-btn" class="btn bg-[#2A3B4D] text-white">üé≤ Random Event</button>
                        <button id="reset-points-btn" class="btn btn-destructive">üîÑ Reset Points</button>
                    </div>
                </section>
            </div>

            <!-- Right Column: Students and History -->
            <div class="lg:col-span-2">
                <section class="bg-[#1A2B3C] p-6 rounded-lg shadow-lg">
                    <div class="flex flex-col md:flex-row justify-between items-center mb-4">
                        <h2 class="text-2xl font-magic-header text-[#FFD700] mb-4 md:mb-0">Student Scrolls</h2>
                        <div class="flex gap-2">
                            <button id="history-log-btn" class="btn bg-[#2A3B4D] text-white">‚è≥ History Log</button>
                        </div>
                    </div>
                    
                    <!-- Student Groups Container -->
                    <div id="student-groups-container" class="bg-[#0C1C33] p-4 rounded-md h-[30rem] overflow-y-auto space-y-6">
                        <!-- Dynamic student group insertion -->
                    </div>
                </section>
            </div>
        </main>
    </div>

    <!-- Spell Effects Container -->
    <div id="spell-effect-container" class="fixed top-0 left-0 w-full h-full pointer-events-none z-50"></div>

    <!-- Modals -->
    <div id="modal" class="modal-backdrop">
        <div id="modal-content" class="modal-content"></div>
    </div>
    <div id="duel-modal" class="modal-backdrop">
        <div id="duel-modal-content" class="modal-content !max-w-4xl"></div>
    </div>
    <div id="library-modal" class="modal-backdrop">
        <div id="library-modal-content" class="modal-content"></div>
    </div>
    <div id="reader-modal" class="modal-backdrop">
        <div id="reader-modal-content" class="modal-content !max-w-4xl !max-h-[95vh]"></div>
    </div>
    <div id="dictionary-modal" class="modal-backdrop">
        <div id="dictionary-modal-content" class="modal-content !max-w-2xl"></div>
    </div>
    <div id="definition-popup-modal" class="modal-backdrop">
        <div id="definition-popup-content" class="modal-content"></div>
    </div>
    <div id="quidditch-modal" class="modal-backdrop">
        <div id="quidditch-modal-content" class="modal-content !max-w-4xl !max-h-[95vh]"></div>
    </div>
    <div id="questions-modal" class="modal-backdrop">
        <div id="questions-modal-content" class="modal-content !max-w-4xl"></div>
    </div>
    <div id="dictionary-training-modal" class="modal-backdrop">
        <div id="dictionary-training-content" class="modal-content !max-w-4xl"></div>
    </div>
    <div id="training-game-modal" class="modal-backdrop">
        <div id="training-game-content" class="modal-content !max-w-2xl"></div>
    </div>
    
    <!-- Reading Mode Container -->
    <div id="reading-mode-container" class="reading-mode hidden">
        <div class="reading-mode-main">
            <div id="reading-mode-content" class="parchment p-8 rounded-lg overflow-y-auto">
                <!-- Content will be injected here -->
            </div>
            <div class="reading-mode-toolbar mt-4 text-center">
                <button id="exit-reading-mode-btn" class="btn btn-gold">Exit Reading Mode</button>
            </div>
        </div>
        <div id="reading-mode-dictionary" class="reading-mode-dictionary rounded-lg p-4">
            <!-- Dictionary will be injected here -->
        </div>
    </div>

<script>
// =================================================================================
// ANIMATED BACKGROUND SCRIPT
// =================================================================================
const canvas = document.getElementById('animated-bg');
const ctx = canvas.getContext('2d');
let particles = [];

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

class Particle {
    constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 2 + 1;
        this.speedX = Math.random() * 1 - 0.5;
        this.speedY = Math.random() * 1 - 0.5;
        this.opacity = Math.random() * 0.5 + 0.2;
    }
    update() {
        this.x += this.speedX;
        this.y += this.speedY;

        if (this.x > canvas.width || this.x < 0) this.speedX *= -1;
        if (this.y > canvas.height || this.y < 0) this.speedY *= -1;
    }
    draw() {
        ctx.fillStyle = `rgba(255, 215, 0, ${this.opacity})`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }
}

function initParticles() {
    particles = [];
    const numberOfParticles = (canvas.width * canvas.height) / 9000;
    for (let i = 0; i < numberOfParticles; i++) {
        particles.push(new Particle());
    }
}

function animateParticles() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let i = 0; i < particles.length; i++) {
        particles[i].update();
        particles[i].draw();
    }
    requestAnimationFrame(animateParticles);
}

window.addEventListener('resize', () => {
    resizeCanvas();
    initParticles();
});

// Initial setup
resizeCanvas();
initParticles();
animateParticles();
</script>

<script type="module">
// =================================================================================
// HOGWARTS TRACKER - REAL-TIME FIRESTORE EDITION
// =================================================================================
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, EmailAuthProvider, reauthenticateWithCredential, updatePassword } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, onSnapshot, setDoc, serverTimestamp, getDoc, collection, getDocs, updateDoc, deleteField, addDoc, query, where, orderBy, Timestamp, writeBatch, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// Firebase configuration
const firebaseConfig = {
  apiKey: "AIzaSyBE3tcke2T88UfnAtAYpPz--g7IbsNDhmY",
  authDomain: "quibbler-club-app.firebaseapp.com",
  projectId: "quibbler-club-app",
  storageBucket: "quibbler-club-app.appspot.com",
  messagingSenderId: "69719922358",
  appId: "1:69719922358:web:ed2f6e129bca1660e6f817",
  measurementId: "G-SNZV5ZS4YB"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// Get DOM element references
const authContainer = document.getElementById('auth-container');
const appContainer = document.getElementById('app-container');
const loginForm = document.getElementById('login-form');
const registerForm = document.getElementById('register-form');
const showRegisterLink = document.getElementById('show-register');
const showLoginLink = document.getElementById('show-login');
const authError = document.getElementById('auth-error');
const logoutBtn = document.getElementById('logout-btn');
const userDisplay = document.getElementById('user-display');
const castSpellBtn = document.getElementById('cast-spell-btn');

// Switch between login and registration forms
showRegisterLink.addEventListener('click', (e) => {
    e.preventDefault();
    loginForm.style.display = 'none';
    registerForm.style.display = 'block';
    showRegisterLink.style.display = 'none';
    showLoginLink.style.display = 'inline';
    authError.textContent = '';
});

showLoginLink.addEventListener('click', (e) => {
    e.preventDefault();
    registerForm.style.display = 'none';
    loginForm.style.display = 'block';
    showLoginLink.style.display = 'none';
    showRegisterLink.style.display = 'inline';
    authError.textContent = '';
});

// Registration handler
registerForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const email = registerForm.email.value;
    const password = registerForm.password.value;
    const passwordConfirm = registerForm.passwordConfirm.value; // Get confirmation password

    // Check if passwords match
    if (password !== passwordConfirm) {
        authError.textContent = "Passwords do not match.";
        return; // Stop the function
    }
    
    authError.textContent = ''; // Clear previous errors

    createUserWithEmailAndPassword(auth, email, password)
        .catch((error) => {
            authError.textContent = error.message;
            console.error('Registration error:', error);
        });
});

// Login handler
loginForm.addEventListener('submit', (e) => {
    e.preventDefault();
    const email = loginForm.email.value;
    const password = loginForm.password.value;
    signInWithEmailAndPassword(auth, email, password)
        .catch((error) => {
            authError.textContent = error.message;
            console.error('Login error:', error);
        });
});

// Logout handler
logoutBtn.addEventListener('click', () => {
    signOut(auth).catch((error) => {
        console.error('Logout error:', error);
    });
});

// Authentication state listener
onAuthStateChanged(auth, (user) => {
    if (user) {
        // User is logged in
        authContainer.style.display = 'none';
        appContainer.style.display = 'block';
        userDisplay.textContent = user.email;
        
        // Initialize the main application logic
        App.init(user.uid, db);
    } else {
        // User is logged out
        authContainer.style.display = 'flex';
        appContainer.style.display = 'none';
        userDisplay.textContent = '';
        if (App.unsubscribeMain) App.unsubscribeMain();
        if (App.unsubscribeSpells) App.unsubscribeSpells();
        if (App.unsubscribeRequests) App.unsubscribeRequests();
        App.userId = null;
        App.currentPlayerName = null;
    }
});


const App = {
    // ==== MAGICAL CONFIGURATION ====
    VERSION: "24.22 Dictionary Training Complete", // Updated version
    ADMIN_UID: "AbgIydNv7Vd0hOTGI6GHYOo2heA2", // <--- YOUR ADMIN UID
    HOUSES: {
        "Gryffindor": { points: 0, color: "#AE0001", secondary: "#FFDB00", animal: "ü¶Å", traits: "Courage, Bravery, Chivalry" },
        "Ravenclaw": { points: 0, color: "#2B4C7E", secondary: "#946B2D", animal: "ü¶Ö", traits: "Intelligence, Wisdom, Creativity" },
        "Hufflepuff": { points: 0, color: "#FFDB00", secondary: "#000000", animal: "ü¶°", traits: "Loyalty, Patience, Justice" },
        "Slytherin": { points: 0, color: "#2A623D", secondary: "#AAAAAA", animal: "üêç", traits: "Ambition, Cunning, Resourcefulness" }
    },
    // Updated default students to form groups of 4
    DEFAULT_STUDENTS: [
        "Harry Potter", "Hermione Granger", "Ron Weasley", "Neville Longbottom",
        "Draco Malfoy", "Vincent Crabbe", "Gregory Goyle", "Pansy Parkinson",
        "Luna Lovegood", "Cho Chang", "Padma Patil", "Terry Boot",
        "Cedric Diggory", "Hannah Abbott", "Susan Bones", "Justin Finch-Fletchley"
    ],
    DEFAULT_HP: 150,
    DEFAULT_MP: 75,
    ACHIEVEMENTS: {
        "Dumbledore's Wisdom": { points: 50, icon: "üéì", description: "For exceptional wisdom and leadership" },
        "Marauder's Mischief": { points: 40, icon: "üåô", description: "For outstanding mischief and creativity" },
        "Patronus Charm": { points: 30, icon: "ü¶å", description: "For mastering advanced defensive magic" },
        "Time-Turner": { points: 60, icon: "‚è≥", description: "For exceptional time-management skills" },
        "Golden Snitch": { points: 100, icon: "‚ö°", description: "For catching the Golden Snitch in Quidditch" },
        "Potions Master": { points: 35, icon: "üß™", description: "For excellence in Potions" },
    },
    SHOP_ITEMS: {
        "Wiggenweld Potion": { cost: 50, icon: "üß™", desc: "A healing potion that restores 50 HP.", effect: { type: 'heal', amount: 50 } },
        "Focus Draught": { cost: 40, icon: "üíß", desc: "A magical draught that restores 40 MP.", effect: { type: 'mp_restore', amount: 40 } },
        "Shielding Brew": { cost: 75, icon: "üõ°Ô∏è", desc: "Creates a temporary magical shield that absorbs 30 damage.", effect: { type: 'add_shield', strength: 30, duration: 2, name: 'Shielding Brew' } },
        "Felix Felicis (Dose)": { cost: 200, icon: "‚ú®", desc: "Grants a guaranteed critical success (d20 = 20) on your next two spell rolls. Single use.", effect: { type: 'guaranteed_hit', duration: 2 } }
    },
    SPELLS: [
        "Expelliarmus", "Stupefy", "Protego", "Insendio", "Diffindo", "Petrificus Totalus",
        "Finite Incantatem", "Episkey", "Confringo", "Bombarda", "Reducto", "Aguamenti",
        "Confundo", "Silencio", "Sectumsempra", "Avada Kedavra", "Crucio", "Imperio"
    ],
    SPELL_DETAILS: {
        "Expelliarmus": { mp: 5, base_dmg: 10, type: "offensive", accuracy: 8, crit_chance: 19, desc: "Disarming charm. Medium damage." },
        "Stupefy": { mp: 8, base_dmg: 15, type: "offensive", accuracy: 9, crit_chance: 19, desc: "Stunning spell. Good damage." },
        "Insendio": { mp: 10, base_dmg: 18, type: "offensive", element: "fire", accuracy: 10, crit_chance: 18, desc: "Fire-making spell. Fire damage." },
        "Diffindo": { mp: 7, base_dmg: 12, type: "offensive", accuracy: 8, crit_chance: 19, desc: "Severing charm. Medium damage." },
        "Reducto": { mp: 12, base_dmg: 22, type: "offensive", accuracy: 11, crit_chance: 18, desc: "Reductor Curse. Significant damage." },
        "Confringo": { mp: 15, base_dmg: 28, type: "offensive", element: "fire", accuracy: 12, crit_chance: 17, desc: "Blasting Curse. High fire damage." },
        "Sectumsempra": { mp: 30, base_dmg: 40, type: "offensive_dark", accuracy: 14, crit_chance: 18, desc: "Dark cutting curse. Severe damage." },
        "Petrificus Totalus": { mp: 10, base_dmg: 5, type: "offensive_bind", effect: "stun", duration: 1, accuracy: 10, effect_chance: 12, desc: "Full Body-Bind. Low damage, may stun." },
        "Confundo": { mp: 10, type: "offensive_utility", effect: "confuse", duration: 1, accuracy: 11, effect_chance: 10, desc: "Confundus Charm. May cause opponent to miss." },
        "Silencio": { mp: 7, type: "offensive_utility", effect: "silence", duration: 1, accuracy: 11, effect_chance: 13, desc: "Silencing Charm. Prevents spellcasting." },
        "Avada Kedavra": { mp: 50, base_dmg: 80, type: "offensive_dark_unforgivable", accuracy: 18, crit_chance: 20, desc: "The Killing Curse. Massive damage." },
        "Crucio": { mp: 35, base_dmg: 20, type: "offensive_dark_unforgivable", effect: "pain_dot", dot_dmg: 8, duration: 2, accuracy: 15, effect_chance: 10, desc: "Cruciatus Curse. Damage + pain over time." },
        "Imperio": { mp: 30, type: "offensive_dark_unforgivable", effect: "control", duration: 1, accuracy: 16, effect_chance: 9, desc: "Imperius Curse. Chance to control opponent." },
        "Protego": { mp: 10, type: "shield", strength: 25, duration: 1, accuracy: 5, desc: "Shield Charm. Blocks/reduces damage." },
        "Finite Incantatem": { mp: 10, type: "counter_utility", accuracy: 6, desc: "General Counter-Spell. Can dispel effects." },
        "Episkey": { mp: 12, base_heal: 30, type: "heal", accuracy: 5, desc: "Healing spell. Restores HP." },
        "Aguamenti": { mp: 5, base_dmg: 5, type: "offensive_utility", element: "water", accuracy: 7, desc: "Water-making spell. Minor water damage." },
    },
    SOUNDS: {
        points: [440, 523, 659], achievement: [784, 659, 523, 659, 784], error: [220, 110],
        sorting: [349, 392, 440, 523, 440, 392, 349], celebration: [659, 698, 784, 880, 784, 698, 659],
        spell_cast_ui: [523, 587, 659, 698, 784], duel_start: [200, 300, 400, 500],
        duel_hit: [600, 400], duel_miss: [300, 200], duel_block: [400, 400], shield_break: [300, 250, 200],
        heal_sound: [587, 698, 784], potion_use: [400, 500, 600], dice_roll: [200, 250, 300, 350, 400, 450, 500],
        crit_fail_sound: [400, 300, 200, 100],
        open_book: [261, 329, 392], turn_page: [392, 440], add_word: [659, 784, 880],
        correct_answer: [523, 659, 784, 1046], incorrect_answer: [349, 261]
    },
    
    // ==== APPLICATION STATE ====
    db: null,
    dbRef: null,
    studentData: {},
    groups: {}, // New: for student groups
    currentAssignments: {},
    history: [],
    userId: null,
    isAdmin: false,
    currentPlayerName: null, 
    unsubscribeMain: null,
    unsubscribeSpells: null,
    unsubscribeRequests: null,
    appStartTime: null,
    logoUrl: "https://placehold.co/80x80/0C1C33/FFD700?text=LOGO",

    // ==== INITIALIZATION ====
    init(userId, db) {
        if (this.userId === userId) return;
        console.log("Initializing Hogwarts Tracker for user:", userId);
        
        this.userId = userId;
        this.db = db;
        this.dbRef = doc(db, "hogwarts-tracker", "main-state");
        this.isAdmin = this.userId === this.ADMIN_UID;
        this.appStartTime = Timestamp.now();
        
        document.getElementById('app-version').textContent = `v${this.VERSION}`;
        
        this.setupRealtimeListeners();
        this.bindEventListeners();
        this.updateAdminControls();
        this.setupLogoUploader();
        
        this.playSound([261, 329, 392], 0.1, "sine");
        DuelingClub.app = this;
        Shop.app = this;
        Library.app = this;
        Dictionary.app = this;
        Quidditch.app = this;
        DiscussionQuestions.app = this;
        DictionaryTraining.app = this;
    },

    // ==== EVENT BINDING ====
    bindEventListeners() {
        if (this.eventsBound) return;
        
        document.getElementById('award-points-btn').addEventListener('click', () => this.openAwardPointsDialog());
        document.getElementById('award-achievement-btn').addEventListener('click', () => this.openAwardAchievementDialog());
        document.getElementById('potion-requests-btn').addEventListener('click', () => this.openPurchaseRequestsDialog());
        document.getElementById('assign-houses-btn').addEventListener('click', () => this.openSortGroupDialog());
        document.getElementById('manage-groups-btn').addEventListener('click', () => this.openManageGroupsDialog());
        document.getElementById('random-event-btn').addEventListener('click', () => this.triggerRandomEvent());
        document.getElementById('reset-points-btn').addEventListener('click', () => this.confirmResetPoints());
        document.getElementById('edit-students-btn').addEventListener('click', () => this.openEditStudentsDialog());
        document.getElementById('link-accounts-btn').addEventListener('click', () => this.openLinkAccountsDialog());
        document.getElementById('history-log-btn').addEventListener('click', () => this.showHistoryLog());
        castSpellBtn.addEventListener('click', () => this.broadcastSpellEffect());
        document.getElementById('dueling-club-btn').addEventListener('click', () => DuelingClub.openDuelSetup());
        document.getElementById('magic-shop-btn').addEventListener('click', () => Shop.open());
        document.getElementById('library-btn').addEventListener('click', () => Library.openLibrary());
        document.getElementById('dictionary-btn').addEventListener('click', () => Dictionary.openDictionary());
        document.getElementById('dictionary-training-btn').addEventListener('click', () => DictionaryTraining.openHub());
        document.getElementById('quidditch-btn').addEventListener('click', () => Quidditch.openGame());
        document.getElementById('questions-btn').addEventListener('click', () => DiscussionQuestions.open());
        document.getElementById('change-password-btn').addEventListener('click', () => this.openChangePasswordDialog());
        
        // Event delegation for student groups container
        document.getElementById('student-groups-container').addEventListener('click', (e) => {
            if (e.target.matches('.profile-btn')) {
                const studentName = e.target.dataset.studentName;
                this.openStudentProfile(studentName);
            }
        });

        // Global listener for Escape key
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                 if (document.getElementById('training-game-modal').classList.contains('show')) {
                    DictionaryTraining.closeGame();
                } else if (document.getElementById('dictionary-training-modal').classList.contains('show')) {
                    document.getElementById('dictionary-training-modal').classList.remove('show');
                } else if (document.getElementById('questions-modal').classList.contains('show')) {
                    DiscussionQuestions.close();
                } else if (document.getElementById('quidditch-modal').classList.contains('show')) {
                    Quidditch.closeGame();
                } else if (document.getElementById('reading-mode-container').classList.contains('reading-mode-active')) {
                    Library.exitReadingMode();
                } else if (document.getElementById('reader-modal').classList.contains('show')) {
                    Library.closeReader();
                } else if (document.getElementById('definition-popup-modal').classList.contains('show')) {
                    document.getElementById('definition-popup-modal').classList.remove('show');
                } else if (document.getElementById('dictionary-modal').classList.contains('show')) {
                    Dictionary.closeDictionary();
                } else if (document.getElementById('library-modal').classList.contains('show')) {
                    document.getElementById('library-modal').classList.remove('show');
                } else if (document.getElementById('duel-modal').classList.contains('show')) {
                    DuelingClub.closeDuelModal();
                } else if (document.getElementById('modal').classList.contains('show')) {
                    this.closeModal();
                }
            }
        });

        this.eventsBound = true;
    },
    
    // ==== REAL-TIME DATABASE ====
    setupRealtimeListeners() {
        if (this.unsubscribeMain) this.unsubscribeMain();
        if (this.unsubscribeSpells) this.unsubscribeSpells();
        if (this.unsubscribeRequests) this.unsubscribeRequests();

        // Listener for main game state
        this.unsubscribeMain = onSnapshot(this.dbRef, (docSnap) => {
            if (docSnap.exists()) {
                console.log("Received real-time update from Firestore.");
                const data = docSnap.data();
                this.HOUSES = data.houses;
                this.studentData = data.studentData;
                this.groups = data.groups || {}; // New
                this.currentAssignments = data.currentAssignments;
                this.history = data.history;
                this.logoUrl = data.logoUrl || "https://placehold.co/80x80/0C1C33/FFD700?text=LOGO";
                document.getElementById('school-logo').src = this.logoUrl;
                this.identifyCurrentUser(); 
                this.updateDisplay();
            } else {
                console.log("No data in Firestore. Creating initial document.");
                if (this.isAdmin) {
                    this.loadDefaultsAndSave();
                } else {
                    document.getElementById('house-points-container').innerHTML = `<p class="text-center text-gray-400">Waiting for Admin to initialize data...</p>`;
                }
            }
        }, (error) => {
            console.error("Firestore listener error:", error);
            this.showNotification("Error connecting to the database.", "error");
        });

        // Listener for spell effects
        const spellsRef = collection(db, "spell-effects");
        const qSpells = query(spellsRef, where("timestamp", ">", this.appStartTime), orderBy("timestamp", "desc"));

        this.unsubscribeSpells = onSnapshot(qSpells, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                if (change.type === "added") {
                    const spellData = change.doc.data();
                    console.log("New spell detected:", spellData.name);
                    this.createVisualSpell(spellData.name, spellData.color);
                    this.showNotification(`${spellData.caster} casts ${spellData.name}!`, 'info');
                }
            });
        }, (error) => {
            console.error("Spell listener error:", error);
        });
        
        // Listener for purchase requests (admin only)
        if (this.isAdmin) {
            const requestsRef = collection(db, "purchase-requests");
            const qRequests = query(requestsRef, where("status", "==", "pending"));
            this.unsubscribeRequests = onSnapshot(qRequests, (snapshot) => {
                const count = snapshot.size;
                const badge = document.getElementById('potion-requests-badge');
                if (count > 0) {
                    badge.textContent = count;
                    badge.classList.remove('hidden');
                } else {
                    badge.classList.add('hidden');
                }
            });
        }
    },
    
    async saveProgress() {
        if (!this.isAdmin) {
            console.warn("Attempt to save by non-admin user was blocked.");
            this.showNotification("Only the administrator can make changes.", "error");
            return;
        }

        const dataToSave = {
            houses: this.HOUSES,
            studentData: this.studentData,
            groups: this.groups, // New
            currentAssignments: this.currentAssignments,
            history: this.history,
            lastUpdated: serverTimestamp(),
            logoUrl: this.logoUrl
        };
        
        try {
            await setDoc(this.dbRef, dataToSave);
            console.log("Progress saved to Firestore by admin.");
        } catch (error) {
            console.error("Error saving to Firestore:", error);
            this.showNotification("Error saving data.", "error");
        }
    },

    loadDefaultsAndSave() {
        console.log("Loading default data and saving to Firestore.");
        for (const houseName in this.HOUSES) {
            this.HOUSES[houseName].points = 0;
        }
        this.studentData = {};
        this.currentAssignments = {};
        this.history = [];
        this.logoUrl = "https://placehold.co/80x80/0C1C33/FFD700?text=LOGO";
        
        // Create student data
        this.DEFAULT_STUDENTS.forEach(name => {
            this.studentData[name] = { points: 0, achievements: [], hp: this.DEFAULT_HP, mp: this.DEFAULT_MP, inventory: [], authUid: null };
        });
        
        // Create default groups of 4
        this.groups = {};
        const groupSize = 4;
        for (let i = 0; i < this.DEFAULT_STUDENTS.length; i += groupSize) {
            const groupStudents = this.DEFAULT_STUDENTS.slice(i, i + groupSize);
            const groupId = `group_${(i/groupSize) + 1}`;
            this.groups[groupId] = {
                name: `Group ${(i/groupSize) + 1}`,
                students: groupStudents
            };
        }

        this.addHistory("System Initialized", "New database document created with student groups.");
        this.saveProgress();
    },

    // ==== CORE DISPLAY LOGIC ====
    updateDisplay() {
        this.updateHousePointsDisplay();
        this.updateStudentGroupsDisplay(); // Changed from updateStudentListDisplay
        this.updateUserDisplay();
    },
    
    updateAdminControls() {
        const adminSection = document.getElementById('admin-controls');
        if (this.isAdmin) {
            adminSection.classList.remove('admin-controls-disabled');
        } else {
            adminSection.classList.add('admin-controls-disabled');
        }
    },

    updateHousePointsDisplay() {
        const container = document.getElementById('house-points-container');
        if (!this.HOUSES) return;

        // NEW: Get sorted houses to determine rank
        const sortedHouses = Object.entries(this.HOUSES).sort(([, a], [, b]) => b.points - a.points);
        
        // NEW: Use grid for layout
        container.className = 'grid grid-cols-2 gap-4';
        container.innerHTML = ''; // Clear previous content

        sortedHouses.forEach(([houseName, house], index) => {
            const rank = index + 1;
            let rankIndicator = '';
            if (rank === 1 && house.points > 0) {
                rankIndicator = `<div class="absolute top-0 right-0 -mt-3 -mr-3 px-2 py-1 bg-yellow-400 text-gray-900 text-xs font-bold rounded-full shadow-lg">1st</div>`;
            }

            const houseEl = document.createElement('div');
            houseEl.className = 'relative p-4 rounded-lg shadow-lg flex flex-col items-center justify-center transition-transform transform hover:scale-105';
            // Use house colors for background/border
            houseEl.style.backgroundColor = house.color;
            houseEl.style.border = `2px solid ${house.secondary}`;
            // Use a dark/light text color based on the background for better contrast
            const textColor = (houseName === 'Hufflepuff') ? 'text-black' : 'text-white';

            houseEl.innerHTML = `
                ${rankIndicator}
                <div class="text-5xl mb-2">${house.animal}</div>
                <h3 class="font-bold text-lg ${textColor} font-magic-header">${houseName}</h3>
                <p class="font-black text-4xl ${textColor}" style="text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">${house.points}</p>
            `;
            container.appendChild(houseEl);
        });
    },

    updateStudentGroupsDisplay() {
        const container = document.getElementById('student-groups-container');
        if (!this.groups || !this.studentData) return;
        container.innerHTML = '';

        if (Object.keys(this.groups).length === 0) {
            container.innerHTML = `<p class="text-center p-4 text-gray-400">No student groups found.</p>`;
            return;
        }

        for (const groupId in this.groups) {
            const group = this.groups[groupId];
            
            const groupContainer = document.createElement('div');
            groupContainer.className = 'mb-6';

            const groupHeader = document.createElement('h3');
            groupHeader.className = 'text-xl font-magic-header text-yellow-300 mb-3 pl-2 border-l-4 border-yellow-300';
            groupHeader.textContent = group.name;
            if (this.isAdmin) {
                groupHeader.contentEditable = true;
                groupHeader.onblur = (e) => this.updateGroupName(groupId, e.target.textContent);
                groupHeader.title = "Click to edit group name";
            }
            groupContainer.appendChild(groupHeader);

            const studentGrid = document.createElement('div');
            studentGrid.className = 'grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4';

            group.students.forEach(studentName => {
                const student = this.studentData[studentName];
                if (!student) return; // Skip if student data doesn't exist

                const houseName = this.currentAssignments[studentName] || 'Unsorted';
                const house = this.HOUSES[houseName] || { color: '#FFFFFF', animal: '‚ùì' };

                const studentCard = document.createElement('div');
                studentCard.className = 'bg-[#1A2B3C] p-3 rounded-lg border border-[#3D5568] flex flex-col justify-between';
                studentCard.innerHTML = `
                    <div>
                        <div class="font-bold text-white">${studentName} ${this.currentPlayerName === studentName ? '(You)' : ''}</div>
                        <div class="text-sm" style="color: ${house.color};">${house.animal} ${houseName}</div>
                    </div>
                    <div class="flex justify-between items-center mt-3">
                        <div class="font-bold text-lg text-[#FFD700]">${student.points} pts</div>
                        <button class="btn text-xs bg-[#3D5568] text-white profile-btn" data-student-name="${studentName}">Profile</button>
                    </div>
                `;
                studentGrid.appendChild(studentCard);
            });
            
            groupContainer.appendChild(studentGrid);
            container.appendChild(groupContainer);
        }
    },
    
    updateUserDisplay() {
        const user = auth.currentUser;
        if (user) {
            let displayText = user.email;
            if (this.currentPlayerName) {
                displayText += ` (as ${this.currentPlayerName})`;
                castSpellBtn.disabled = false;
                castSpellBtn.title = "Cast a spell for everyone to see!";
            } else if (!this.isAdmin) {
                displayText += ` (Spectator)`;
                castSpellBtn.disabled = true;
                castSpellBtn.title = "Link your account to a student to cast spells.";
            } else {
                 castSpellBtn.disabled = false;
                 castSpellBtn.title = "Admins can cast shared spells.";
            }
            userDisplay.textContent = displayText;
        }
    },
    
    // ==== MODALS AND DIALOGS ====
    openModal(title, contentHTML, onConfirm, confirmText = 'Confirm') {
        const modal = document.getElementById('modal');
        const modalContent = document.getElementById('modal-content');
        
        modalContent.innerHTML = `
            <span class="modal-close-btn" onclick="App.closeModal()">&times;</span>
            <h3 class="font-magic-header text-2xl text-[#FFD700] mb-4">${title}</h3>
            <div class="space-y-4">${contentHTML}</div>
            <div class="flex justify-end gap-4 mt-6">
                <button id="modal-cancel" class="btn bg-gray-600 text-white">Cancel</button>
                ${onConfirm ? `<button id="modal-confirm" class="btn btn-gold">${confirmText}</button>` : ''}
            </div>
        `;
        
        modal.classList.add('show');

        modal.querySelector('#modal-cancel').addEventListener('click', () => this.closeModal());
        if (onConfirm) {
            const confirmBtn = modal.querySelector('#modal-confirm');
            confirmBtn.addEventListener('click', () => {
                onConfirm();
            });
        }
    },

    closeModal() {
        document.getElementById('modal').classList.remove('show');
    },
    
    openAwardPointsDialog() {
        const studentOptions = ['(Entire House)', ...Object.keys(this.studentData).sort()];
        const houseOptions = Object.keys(this.HOUSES);

        const content = `
            <div>
                <label class="block mb-1 text-sm font-medium">Target Student (optional)</label>
                <select id="points-student" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
                    ${studentOptions.map(s => `<option value="${s}">${s}</option>`).join('')}
                </select>
            </div>
            <div>
                <label class="block mb-1 text-sm font-medium">Target House</label>
                <select id="points-house" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
                    ${houseOptions.map(h => `<option value="${h}">${h}</option>`).join('')}
                </select>
            </div>
            <div class="flex items-center gap-4">
                <input id="points-amount" type="number" value="10" class="w-24 bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
                <div class="flex gap-4">
                    <label><input type="radio" name="points-action" value="add" checked> Add</label>
                    <label><input type="radio" name="points-action" value="deduct"> Deduct</label>
                </div>
            </div>
            <div>
                <label class="block mb-1 text-sm font-medium">Reason</label>
                <input id="points-reason" type="text" placeholder="For excellent performance" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
            </div>
        `;

        this.openModal('Award/Deduct Points', content, () => {
            const student = document.getElementById('points-student').value;
            const house = document.getElementById('points-house').value;
            let amount = parseInt(document.getElementById('points-amount').value) || 0;
            const action = document.querySelector('input[name="points-action"]:checked').value;
            const reason = document.getElementById('points-reason').value || 'Student/House performance';
            if (action === 'deduct') amount = -amount;

            let historyAction = '';
            if (student !== '(Entire House)') {
                 if (this.currentAssignments[student] !== house) {
                    this.showNotification(`Error: ${student} is not in ${house}.`, 'error');
                    return;
                }
                this.studentData[student].points += amount;
                historyAction = `${amount > 0 ? '+' : ''}${amount} points to ${student} (${house})`;
            } else {
                Object.keys(this.currentAssignments).forEach(sName => {
                    if (this.currentAssignments[sName] === house) {
                        this.studentData[sName].points += amount;
                    }
                });
                historyAction = `${amount > 0 ? '+' : ''}${amount} points to everyone in ${house}`;
            }

            this.HOUSES[house].points += amount;
            this.addHistory(historyAction, reason);
            this.playSound(this.SOUNDS.points);
            this.saveProgress();
            this.closeModal();
        }, 'Apply');

        // Add listener to auto-select house
        const studentSelect = document.getElementById('points-student');
        const houseSelect = document.getElementById('points-house');
        studentSelect.addEventListener('change', (e) => {
            const selectedStudent = e.target.value;
            if (selectedStudent !== '(Entire House)') {
                const studentHouse = this.currentAssignments[selectedStudent];
                if (studentHouse) {
                    houseSelect.value = studentHouse;
                    houseSelect.disabled = true;
                }
            } else {
                houseSelect.disabled = false;
            }
        });
    },

    openAwardAchievementDialog() {
        if (Object.keys(this.studentData).length === 0) {
            this.showNotification("Add students first.", "error");
            return;
        }
        const studentOptions = Object.keys(this.studentData).sort();
        const achievementOptions = Object.keys(this.ACHIEVEMENTS);

        const content = `
             <div>
                <label class="block mb-1 text-sm font-medium">Select Student</label>
                <select id="ach-student" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
                    ${studentOptions.map(s => `<option value="${s}">${s}</option>`).join('')}
                </select>
            </div>
            <div>
                <label class="block mb-1 text-sm font-medium">Select Achievement</label>
                <select id="ach-name" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
                    ${achievementOptions.map(a => `<option value="${a}">${a} (+${this.ACHIEVEMENTS[a].points} points)</option>`).join('')}
                </select>
            </div>
            <div>
                <label class="block mb-1 text-sm font-medium">Reason</label>
                <input id="ach-reason" type="text" placeholder="For an exceptional act" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
            </div>
        `;
        
        this.openModal('Grant Achievement', content, () => {
            const student = document.getElementById('ach-student').value;
            const achievementName = document.getElementById('ach-name').value;
            const reason = document.getElementById('ach-reason').value || 'Exceptional act';
            const house = this.currentAssignments[student];

            if (!house) {
                this.showNotification(`${student} is not in a house!`, 'error');
                return;
            }

            const achievement = this.ACHIEVEMENTS[achievementName];
            this.studentData[student].points += achievement.points;
            if (!this.studentData[student].achievements.includes(achievementName)) {
                this.studentData[student].achievements.push(achievementName);
            }
            this.HOUSES[house].points += achievement.points;

            this.addHistory(`Granted '${achievementName}' to ${student}`, reason);
            this.playSound(this.SOUNDS.achievement);
            this.saveProgress();
            this.closeModal();
            this.showNotification(`‚ú® ${student} earned the '${achievementName}' achievement!`, 'success');
        }, 'Grant');
    },

    openEditStudentsDialog() {
        const renderStudentList = () => {
            return Object.keys(this.studentData).sort().map(name => `
                <div class="flex items-center gap-2 mb-2">
                    <input type="text" value="${name}" data-original-name="${name}" class="student-name-entry flex-grow bg-[#0C1C33] p-2 rounded border border-[#3D5568]">
                    <button class="btn-destructive text-sm p-2 remove-student-btn" data-student-name="${name}">üóëÔ∏è</button>
                </div>
            `).join('');
        };

        const content = `
            <p class="text-sm text-gray-400 mb-4">Add or remove students from the master list. This does not assign them to groups.</p>
            <div class="flex gap-2 mb-4">
                <input id="new-student-name" type="text" placeholder="New student name" class="flex-grow bg-[#0C1C33] p-2 rounded border border-[#3D5568]">
                <button id="add-student-btn" class="btn btn-gold">Add</button>
            </div>
            <div id="edit-student-list-container" class="max-h-64 overflow-y-auto">
                ${renderStudentList()}
            </div>
        `;

        this.openModal('Manage Student Roster', content, () => {
            const entries = document.querySelectorAll('.student-name-entry');
            let historyAdded = false;
            entries.forEach(entry => {
                const oldName = entry.dataset.originalName;
                const newName = entry.value.trim();
                if (newName && newName !== oldName) {
                    if (this.studentData[newName]) {
                        this.showNotification(`A student named "${newName}" already exists.`, 'error');
                        entry.value = oldName; // revert
                    } else {
                        // This part is complex with groups. A simple rename is okay.
                        const oldStudentData = this.studentData[oldName];
                        this.studentData[newName] = oldStudentData;
                        delete this.studentData[oldName];

                        if (this.currentAssignments[oldName]) {
                            this.currentAssignments[newName] = this.currentAssignments[oldName];
                            delete this.currentAssignments[oldName];
                        }
                        
                        // Update name in groups
                        for(const groupId in this.groups) {
                            const studentIndex = this.groups[groupId].students.indexOf(oldName);
                            if (studentIndex > -1) {
                                this.groups[groupId].students[studentIndex] = newName;
                            }
                        }

                        if (!historyAdded) {
                           this.addHistory('Updated names in student list.', 'Manual edit');
                           historyAdded = true;
                        }
                    }
                }
            });
            this.saveProgress();
            this.closeModal();
        }, 'Save & Close');
        
        const modalContent = document.getElementById('modal-content');

        // Add student logic
        modalContent.querySelector('#add-student-btn').addEventListener('click', () => {
            const newNameInput = document.getElementById('new-student-name');
            const newName = newNameInput.value.trim();
            if (newName && !this.studentData[newName]) {
                this.studentData[newName] = { points: 0, achievements: [], hp: this.DEFAULT_HP, mp: this.DEFAULT_MP, inventory: [], authUid: null };
                this.addHistory(`Added new student: ${newName}`, 'Manual addition');
                this.saveProgress();
                this.closeModal();
                this.openEditStudentsDialog();
            } else if (this.studentData[newName]) {
                this.showNotification(`Student "${newName}" already exists!`, 'error');
            }
        });

        // Remove student logic using event delegation
        modalContent.querySelector('#edit-student-list-container').addEventListener('click', (e) => {
            if (e.target.matches('.remove-student-btn')) {
                const studentName = e.target.dataset.studentName;
                const confirmationContent = `<p>Are you sure you want to remove ${studentName} from the school? This will also remove them from any group they are in. This action is irreversible.</p>`;
                this.openModal('Confirm Deletion', confirmationContent, () => {
                    // This is a "sub-modal", so we close it and then proceed.
                    this.closeModal(); 
                    
                    delete this.studentData[studentName];
                    delete this.currentAssignments[studentName];
                    // Also remove from groups
                    for(const groupId in this.groups) {
                        this.groups[groupId].students = this.groups[groupId].students.filter(s => s !== studentName);
                    }
                    this.addHistory(`Removed student: ${studentName}`, 'Manual removal from roster');
                    this.saveProgress();
                    
                    // Re-open the edit modal to show the change
                    this.openEditStudentsDialog(); 
                }, 'Delete');
            }
        });
    },
    
    openLinkAccountsDialog() {
        const studentRows = Object.keys(this.studentData).sort().map(name => {
            const student = this.studentData[name];
            const currentUid = student.authUid || '';
            return `
                <div class="grid grid-cols-2 gap-4 items-center mb-2">
                    <label for="uid-${name}" class="text-right">${name}:</label>
                    <input type="text" id="uid-${name}" data-student-name="${name}" value="${currentUid}" placeholder="Not Linked" class="account-uid-entry bg-[#0C1C33] p-2 rounded border border-[#3D5568] text-sm">
                </div>
            `;
        }).join('');

        const content = `
            <p class="text-sm text-gray-400 mb-4">
                Enter the Firebase Auth UID for each student to link their login account to their profile. You can find the UID in the Firebase Console under Authentication.
            </p>
            <div id="link-accounts-list" class="max-h-72 overflow-y-auto">
                ${studentRows}
            </div>
        `;

        this.openModal('Link Student Accounts', content, () => {
            const inputs = document.querySelectorAll('.account-uid-entry');
            let changesMade = false;
            inputs.forEach(input => {
                const studentName = input.dataset.studentName;
                const newUid = input.value.trim() || null; 
                if (this.studentData[studentName].authUid !== newUid) {
                    this.studentData[studentName].authUid = newUid;
                    changesMade = true;
                }
            });

            if (changesMade) {
                this.addHistory('Updated student account links', 'Admin action');
                this.saveProgress();
                this.showNotification('Account links updated successfully!', 'success');
            }
            this.closeModal();
        }, 'Save Links');
    },
    
    openStudentProfile(studentName) {
        const student = this.studentData[studentName];
        const houseName = this.currentAssignments[studentName] || 'Unsorted';
        const house = this.HOUSES[houseName] || { color: '#FFFFFF', animal: '‚ùì', traits: 'N/A' };
        
        const achievementsHTML = student.achievements.length > 0 ? 
            student.achievements.map(achName => {
                const ach = this.ACHIEVEMENTS[achName];
                return `<div class="flex items-center gap-2"><span class="text-xl">${ach.icon}</span> <span>${achName}</span></div>`;
            }).join('') : '<p class="text-gray-400">No achievements yet.</p>';

        const inventoryHTML = student.inventory && student.inventory.length > 0 ?
            student.inventory.map(itemName => {
                const item = this.SHOP_ITEMS[itemName];
                const removeBtn = this.isAdmin ? `<button class="btn-destructive text-xs p-1" onclick="App.adminRemoveItem('${studentName}', '${itemName}')">X</button>` : '';
                return `<div class="flex items-center justify-between"><div class="flex items-center gap-2"><span class="text-xl">${item.icon}</span> <span>${itemName}</span></div> ${removeBtn}</div>`;
            }).join('') : '<p class="text-gray-400">No items.</p>';
        
        const adminInventoryControls = this.isAdmin ? `
            <div class="flex gap-2 mt-2">
                <select id="admin-add-item-select" class="w-full bg-[#2A3B4D] rounded p-1 border border-[#3D5568] text-sm">
                    ${Object.keys(this.SHOP_ITEMS).map(name => `<option value="${name}">${name}</option>`).join('')}
                </select>
                <button class="btn btn-gold text-sm" onclick="App.adminAddItem('${studentName}')">Add</button>
            </div>
        ` : '';

        const studentHistory = this.history.filter(entry => entry.action.includes(studentName));
        const historyHTML = studentHistory.length > 0 ? studentHistory.slice().reverse().map(entry => `
            <div class="p-2 border-b border-gray-700 text-sm">
                <p class="font-semibold">${entry.action}</p>
                <p class="text-gray-400 italic">"${entry.reason}" - ${entry.date}</p>
            </div>
        `).join('') : '<p class="text-gray-400">No points history.</p>';

        const content = `
            <div class="flex items-center gap-4 mb-4">
                <div class="text-6xl">${house.animal}</div>
                <div>
                    <h4 class="text-xl font-bold" style="color: ${house.color};">${studentName}</h4>
                    <p class="text-lg">${houseName}</p>
                </div>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div><strong>Points:</strong> <span class="text-[#FFD700]">${student.points}</span></div>
                <div><strong>HP:</strong> ${student.hp} / ${this.DEFAULT_HP}</div>
                <div><strong>MP:</strong> ${student.mp} / ${this.DEFAULT_MP}</div>
                <div><strong>Traits:</strong> ${house.traits}</div>
            </div>
            <div class="mt-4">
                <button class="btn btn-gold w-full" onclick="DiscussionQuestions.showStudentHomework('${studentName}')">üéì View Homework</button>
            </div>
            <hr class="my-4 border-gray-600">
            <h5 class="font-bold mb-2">üéí Inventory</h5>
            <div class="space-y-1 mb-2">${inventoryHTML}</div>
            ${adminInventoryControls}
            <hr class="my-4 border-gray-600">
            <h5 class="font-bold mb-2">üåü Achievements</h5>
            <div class="space-y-1 mb-2">${achievementsHTML}</div>
            <hr class="my-4 border-gray-600">
            <h5 class="font-bold mb-2">üìú Points History</h5>
            <div class="space-y-1 max-h-32 overflow-y-auto">${historyHTML}</div>
        `;
        this.openModal(`Student Profile: ${studentName}`, content, null);
    },

    showHistoryLog() {
        const historyHTML = this.history.slice().reverse().map(entry => `
            <div class="p-2 border-b border-gray-700">
                <p class="text-sm text-gray-400">${entry.date}</p>
                <p class="font-semibold">${entry.action}</p>
                <p class="text-sm text-gray-300 italic">"${entry.reason}"</p>
            </div>
        `).join('');

        const content = `<div class="max-h-96 overflow-y-auto">${historyHTML || '<p>Log is empty.</p>'}</div>`;
        this.openModal('Magical History Log', content);
    },
    
    // ==== CORE LOGIC ====
    identifyCurrentUser() {
        this.currentPlayerName = null;
        if (this.userId && this.studentData) {
            for (const studentName in this.studentData) {
                if (this.studentData[studentName].authUid === this.userId) {
                    this.currentPlayerName = studentName;
                    break;
                }
            }
        }
        console.log(`Current player identified as: ${this.currentPlayerName || 'None'}`);
    },

    openSortGroupDialog() {
        if (Object.keys(this.groups).length === 0) {
            this.showNotification("There are no groups to sort!", "error");
            return;
        }

        const groupOptions = Object.keys(this.groups).map(id => {
            const group = this.groups[id];
            return `<option value="${id}">${group.name}</option>`;
        }).join('');

        const content = `
            <div>
                <label for="group-to-sort" class="block mb-2 text-sm font-medium">Which group will the Sorting Hat sort?</label>
                <select id="group-to-sort" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
                    ${groupOptions}
                </select>
            </div>
        `;

        this.openModal('Sorting Ceremony', content, () => {
            const groupId = document.getElementById('group-to-sort').value;
            this.assignHousesForGroup(groupId);
            this.closeModal();
        }, 'Sort Group');
    },

    assignHousesForGroup(groupId) {
        const group = this.groups[groupId];
        if (!group || group.students.length === 0) {
            this.showNotification("Selected group is empty or invalid.", "error");
            return;
        }

        const studentsToSort = group.students;
        const houses = Object.keys(this.HOUSES);
        
        this.playSound(this.SOUNDS.sorting, 0.2);
        
        // Simple round-robin assignment
        let houseIndex = 0;
        let assignmentsText = `The Sorting Ceremony for ${group.name} is complete:\n`;
        
        studentsToSort.forEach((student) => {
            const assignedHouse = houses[houseIndex];
            this.currentAssignments[student] = assignedHouse;
            assignmentsText += `- ${student}: ${assignedHouse}\n`;
            houseIndex = (houseIndex + 1) % houses.length;
        });

        this.addHistory(`Sorted Group: ${group.name}`, assignmentsText);
        this.saveProgress();
        this.showNotification(`üé© ${group.name} has been sorted!`, "success");
    },
    
    // =================================================================================
    // ==== NEW GROUP MANAGEMENT LOGIC ====
    // =================================================================================
    openManageGroupsDialog() {
        const getUnassignedStudents = () => {
            const allStudents = new Set(Object.keys(this.studentData));
            const assignedStudents = new Set();
            Object.values(this.groups).forEach(group => {
                group.students.forEach(student => assignedStudents.add(student));
            });
            return [...allStudents].filter(student => !assignedStudents.has(student));
        };

        const renderGroupManager = () => {
            let html = '';
            const groupOptions = Object.keys(this.groups).map(id => `<option value="${id}">${this.groups[id].name}</option>`).join('');

            for (const groupId in this.groups) {
                const group = this.groups[groupId];
                const studentListHTML = group.students.map(studentName => `
                    <div class="flex items-center justify-between bg-[#0C1C33] p-2 rounded">
                        <span>${studentName}</span>
                        <div class="flex items-center gap-1">
                            <select class="transfer-student-select bg-[#2A3B4D] text-xs p-1 rounded" data-student-name="${studentName}" data-source-group="${groupId}">
                                <option value="">Transfer to...</option>
                                ${Object.keys(this.groups).filter(id => id !== groupId).map(id => `<option value="${id}">${this.groups[id].name}</option>`).join('')}
                            </select>
                            <button class="btn-destructive text-xs p-1" onclick="App.removeStudentFromGroup('${studentName}', '${groupId}')" title="Remove from group">‚úñ</button>
                        </div>
                    </div>
                `).join('');

                const unassignedStudents = getUnassignedStudents();
                const addStudentDropdownHTML = unassignedStudents.length > 0 ? `
                    <div class="flex gap-2 mt-2">
                        <select id="add-student-select-${groupId}" class="w-full bg-[#2A3B4D] p-1 rounded border border-[#3D5568] text-sm">
                            ${unassignedStudents.map(s => `<option value="${s}">${s}</option>`).join('')}
                        </select>
                        <button class="btn btn-gold text-sm" onclick="App.addStudentToGroup('${groupId}')">Add</button>
                    </div>
                ` : '<p class="text-xs text-gray-400 mt-2">No unassigned students available.</p>';

                html += `
                    <div class="bg-[#1A2B3C] p-4 rounded-lg border border-[#3D5568]">
                        <div class="flex justify-between items-center mb-2">
                            <h4 class="font-bold text-lg text-yellow-300">${group.name}</h4>
                            <button class="btn btn-destructive text-sm" onclick="App.deleteGroup('${groupId}')">Delete Group</button>
                        </div>
                        <div class="space-y-2 mb-2">${studentListHTML || '<p class="text-sm text-gray-400">This group is empty.</p>'}</div>
                        ${addStudentDropdownHTML}
                    </div>
                `;
            }
            return html;
        };
        
        const content = `
            <div id="group-manager-container" class="space-y-4 max-h-[70vh] overflow-y-auto pr-2">
                ${renderGroupManager()}
            </div>
            <hr class="my-4 border-gray-600">
            <div>
                <h4 class="font-bold text-lg text-yellow-300 mb-2">Create New Group</h4>
                <div class="flex gap-2">
                    <input id="new-group-name" type="text" placeholder="New group name" class="flex-grow bg-[#0C1C33] p-2 rounded border border-[#3D5568]">
                    <button class="btn btn-gold" onclick="App.createGroup()">Create</button>
                </div>
            </div>
        `;

        this.openModal('Manage Groups', content, () => {
            this.closeModal();
        }, 'Done');

        // Add event listener for transfer dropdowns
        document.querySelectorAll('.transfer-student-select').forEach(select => {
            select.addEventListener('change', (e) => {
                const studentName = e.target.dataset.studentName;
                const sourceGroupId = e.target.dataset.sourceGroup;
                const destGroupId = e.target.value;
                if (studentName && sourceGroupId && destGroupId) {
                    this.transferStudent(studentName, sourceGroupId, destGroupId);
                }
            });
        });
    },

    createGroup() {
        const groupNameInput = document.getElementById('new-group-name');
        const groupName = groupNameInput.value.trim();
        if (!groupName) {
            this.showNotification("Group name cannot be empty.", "error");
            return;
        }

        const newGroupId = `group_${Date.now()}`;
        this.groups[newGroupId] = { name: groupName, students: [] };
        
        this.addHistory(`Created new group: ${groupName}`, 'Admin action');
        this.saveProgress();
        this.openManageGroupsDialog(); // Refresh the dialog
    },

    deleteGroup(groupId) {
        const groupName = this.groups[groupId].name;
        const confirmationContent = `<p>Are you sure you want to permanently delete the group "${groupName}"? The students will become unassigned but will not be deleted.</p>`;
        this.openModal('Confirm Deletion', confirmationContent, () => {
            delete this.groups[groupId];
            this.addHistory(`Deleted group: ${groupName}`, 'Admin action');
            this.saveProgress();
            this.closeModal(); // Close confirmation
            this.openManageGroupsDialog(); // Refresh main dialog
        }, 'Delete');
    },

    addStudentToGroup(groupId) {
        const select = document.getElementById(`add-student-select-${groupId}`);
        const studentName = select.value;
        if (!studentName) {
            this.showNotification("No student selected.", "error");
            return;
        }

        this.groups[groupId].students.push(studentName);
        this.addHistory(`Added ${studentName} to group ${this.groups[groupId].name}`, 'Admin action');
        this.saveProgress();
        this.openManageGroupsDialog(); // Refresh
    },

    removeStudentFromGroup(studentName, groupId) {
        this.groups[groupId].students = this.groups[groupId].students.filter(s => s !== studentName);
        this.addHistory(`Removed ${studentName} from group ${this.groups[groupId].name}`, 'Admin action');
        this.saveProgress();
        this.openManageGroupsDialog(); // Refresh
    },

    transferStudent(studentName, sourceGroupId, destGroupId) {
        // Remove from source
        this.groups[sourceGroupId].students = this.groups[sourceGroupId].students.filter(s => s !== studentName);
        // Add to destination
        this.groups[destGroupId].students.push(studentName);
        
        this.addHistory(`Transferred ${studentName} from ${this.groups[sourceGroupId].name} to ${this.groups[destGroupId].name}`, 'Admin action');
        this.saveProgress();
        this.showNotification(`Transferred ${studentName} successfully.`, 'success');
        this.openManageGroupsDialog(); // Refresh
    },
    
    // =================================================================================

    triggerRandomEvent() {
        const events = [
            { name: "Successful Quidditch practice pays off!", p1: 10, p2: 5 },
            { name: "A minor incident in Potions class.", p1: -5, p2: 0 },
            { name: "Helpful research in the library.", p1: 10, p2: 0 },
            { name: "Peeves causes a bit of a ruckus.", p1: -3, p2: -3 },
        ];
        const event = events[Math.floor(Math.random() * events.length)];
        const houses = Object.keys(this.HOUSES);
        const [h1, h2] = houses.sort(() => 0.5 - Math.random());

        this.HOUSES[h1].points += event.p1;
        this.HOUSES[h2].points += event.p2;

        const reason = `${h1}: ${event.p1 > 0 ? '+' : ''}${event.p1} points, ${h2}: ${event.p2 > 0 ? '+' : ''}${event.p2} points.`;
        this.addHistory(`Random Event: ${event.name}`, reason);
        this.saveProgress();
        this.showNotification(`‚ö° Random Event: ${event.name}!`, 'success');
    },

    confirmResetPoints() {
        const confirmationContent = `<p>Reset ALL house and student points to their initial values? This action is irreversible!</p>`;
        this.openModal('Confirm Reset', confirmationContent, () => {
            this.loadDefaultsAndSave();
            this.playSound(this.SOUNDS.error);
            this.showNotification("All points have been reset.", "success");
            this.closeModal();
        }, 'Reset');
    },

    async broadcastSpellEffect() {
        const casterName = this.isAdmin ? "The Headmaster" : this.currentPlayerName;
        if (!casterName) {
            this.showNotification("Only linked students can cast shared spells.", "error");
            return;
        }
        const spellName = this.SPELLS[Math.floor(Math.random() * this.SPELLS.length)];
        const houseName = this.currentAssignments[this.currentPlayerName] || 'Gryffindor';
        const houseColor = this.HOUSES[houseName].color;

        try {
            await addDoc(collection(db, "spell-effects"), {
                name: spellName,
                color: houseColor,
                caster: casterName,
                timestamp: serverTimestamp()
            });
        } catch (error) {
            console.error("Error broadcasting spell:", error);
            this.showNotification("Could not cast the spell.", "error");
        }
    },

    createVisualSpell(spellName, color) {
        const container = document.getElementById('spell-effect-container');
        const spellEl = document.createElement('div');
        spellEl.className = 'spell-effect';
        spellEl.textContent = `‚ú® ${spellName} ‚ú®`;
        
        const startX = Math.random() * window.innerWidth;
        spellEl.style.left = `${startX}px`;
        spellEl.style.bottom = '0px';
        spellEl.style.color = color || '#FFD700';

        container.appendChild(spellEl);
        this.playSound(this.SOUNDS.spell_cast_ui, 0.1);

        setTimeout(() => {
            spellEl.remove();
        }, 1500);
    },

    // ==== UTILITIES & HELPERS ====
    addHistory(action, reason) {
        const date = new Date().toLocaleString('en-US');
        this.history.push({ date, action, reason });
        if (this.history.length > 100) {
            this.history.shift();
        }
    },

    playSound(notes, duration = 0.1, type = "triangle") {
        if (typeof Tone === 'undefined') return;
        try {
            const synth = new Tone.Synth({
                oscillator: { type },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 }
            }).toDestination();
            
            const now = Tone.now();
            if (Array.isArray(notes)) {
                notes.forEach((note, i) => {
                    synth.triggerAttackRelease(note, "8n", now + i * duration);
                });
            } else {
                synth.triggerAttackRelease(notes, "8n", now);
            }
        } catch (e) {
            console.error("Error playing sound:", e);
        }
    },

    showNotification(message, type = 'success') {
        const notif = document.createElement('div');
        notif.textContent = message;
        notif.className = `fixed bottom-5 right-5 p-4 rounded-lg shadow-lg text-white font-bold z-[3000]`; // Increased z-index
        
        let bgColor;
        switch(type) {
            case 'success':
                bgColor = '#2A623D';
                break;
            case 'error':
                bgColor = '#AE0001';
                break;
            case 'info':
                bgColor = '#2B4C7E'; // Ravenclaw blue for info
                break;
            default:
                bgColor = '#2A623D';
        }
        notif.style.backgroundColor = bgColor;

        document.body.appendChild(notif);
        setTimeout(() => {
            notif.remove();
        }, 3000);
    },

    updateGroupName(groupId, newName) {
        if (!this.isAdmin) return;
        const cleanedName = newName.trim();
        if (cleanedName && this.groups[groupId] && this.groups[groupId].name !== cleanedName) {
            this.groups[groupId].name = cleanedName;
            this.addHistory(`Renamed group to "${cleanedName}"`, 'Admin action');
            this.saveProgress();
            this.showNotification(`Group renamed to "${cleanedName}"`, 'success');
        }
    },

    // ==== LOGO FUNCTIONALITY ====
    setupLogoUploader() {
        const logoImg = document.getElementById('school-logo');
        const logoUploadInput = document.getElementById('logo-upload');
        const logoContainer = logoImg.parentElement;

        if (this.isAdmin) {
            logoContainer.addEventListener('click', () => {
                logoUploadInput.click();
            });

            logoUploadInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imageDataUrl = e.target.result;
                        this.logoUrl = imageDataUrl;
                        this.saveProgress();
                        this.showNotification('Logo updated successfully!', 'success');
                    };
                    reader.readAsDataURL(file);
                }
            });
        } else {
            // Remove hover effect for non-admin
            logoContainer.classList.remove('group');
            const hoverDiv = logoContainer.querySelector('div');
            if (hoverDiv) hoverDiv.remove();
            logoContainer.style.cursor = 'default';
        }
    },

    // ==== NEW POTION & INVENTORY LOGIC ====
    async requestPurchase(studentName, itemName) {
        const item = this.SHOP_ITEMS[itemName];
        const student = this.studentData[studentName];
        if (!item || !student) return;

        if (student.points < item.cost) {
            this.showNotification("You do not have enough points for this item.", "error");
            return;
        }

        try {
            await addDoc(collection(db, "purchase-requests"), {
                studentName,
                itemName,
                itemCost: item.cost,
                status: "pending",
                timestamp: serverTimestamp()
            });
            this.showNotification("Purchase request sent to the admin for approval.", "success");
            this.closeModal();
        } catch (error) {
            console.error("Error sending purchase request:", error);
            this.showNotification("Could not send purchase request.", "error");
        }
    },

    async openPurchaseRequestsDialog() {
        try {
            const requestsRef = collection(db, "purchase-requests");
            const q = query(requestsRef, where("status", "==", "pending"), orderBy("timestamp", "asc"));
            const snapshot = await getDocs(q);

            let requestsHTML = '';
            if (snapshot.empty) {
                requestsHTML = '<p class="text-center text-gray-400">No pending requests.</p>';
            } else {
                snapshot.forEach(doc => {
                    const req = doc.data();
                    const item = this.SHOP_ITEMS[req.itemName];
                    if (!item) return; // Skip if item is no longer sold
                    requestsHTML += `
                        <div class="p-3 bg-[#0C1C33] rounded-lg border border-[#3D5568] flex justify-between items-center">
                            <div>
                                <p><strong>${req.studentName}</strong> requests <strong>${item.icon} ${req.itemName}</strong></p>
                                <p class="text-sm text-gray-400">Cost: ${req.itemCost} points</p>
                            </div>
                            <div class="flex gap-2">
                                <button class="btn bg-green-600 text-white text-sm" onclick="App.handlePurchaseRequest('${doc.id}', true)">Approve</button>
                                <button class="btn btn-destructive text-sm" onclick="App.handlePurchaseRequest('${doc.id}', false)">Deny</button>
                            </div>
                        </div>
                    `;
                });
            }

            const content = `<div class="space-y-3 max-h-96 overflow-y-auto">${requestsHTML}</div>`;
            this.openModal('Potion Purchase Requests', content);
        } catch (error) {
            console.error("Error opening purchase requests:", error);
            this.showNotification("Could not load purchase requests. Check console for details.", "error");
            const content = `<p class="text-red-400">Failed to load requests. This is likely due to a missing Firestore index. Please check the browser console (F12) for a detailed error message and a link to create the necessary index.</p>`;
            this.openModal('Error Loading Requests', content);
        }
    },

    async handlePurchaseRequest(requestId, isApproved) {
        if (!this.isAdmin) return;

        const requestRef = doc(db, "purchase-requests", requestId);
        const requestSnap = await getDoc(requestRef);
        if (!requestSnap.exists()) {
            this.showNotification("Request not found.", "error");
            return;
        }

        const requestData = requestSnap.data();
        const { studentName, itemName, itemCost } = requestData;
        
        const batch = writeBatch(db);
        const mainStateRef = this.dbRef;

        if (isApproved) {
            const latestDoc = await getDoc(mainStateRef);
            const latestStudentData = latestDoc.data().studentData;
            const student = latestStudentData[studentName];
            
            if (!student) {
                this.showNotification(`Student ${studentName} not found.`, "error");
                batch.update(requestRef, { status: "denied", reason: "Student not found" });
            } else if (student.points < itemCost) {
                this.showNotification(`${studentName} no longer has enough points.`, "error");
                batch.update(requestRef, { status: "denied", reason: "Insufficient points" });
            } else {
                student.points -= itemCost;
                if (!student.inventory) student.inventory = [];
                student.inventory.push(itemName);
                
                batch.update(mainStateRef, { [`studentData.${studentName}`]: student });
                
                batch.update(requestRef, { status: "approved" });
                this.addHistory(`Approved ${itemName} for ${studentName}`, `Cost: ${itemCost} points.`);
                this.showNotification("Purchase approved!", "success");
            }
        } else {
            batch.update(requestRef, { status: "denied", reason: "Admin denied" });
            this.showNotification("Purchase denied.", "info");
        }

        await batch.commit();
        this.openPurchaseRequestsDialog(); // Refresh the dialog
    },
    
    async adminAddItem(studentName) {
        const itemName = document.getElementById('admin-add-item-select').value;
        if (!itemName) return;

        const student = this.studentData[studentName];
        if (!student.inventory) student.inventory = [];
        student.inventory.push(itemName);

        await updateDoc(this.dbRef, { [`studentData.${studentName}`]: student });
        this.showNotification(`Added ${itemName} to ${studentName}'s inventory.`, 'success');
        this.openStudentProfile(studentName); // Refresh profile
    },

    async adminRemoveItem(studentName, itemName) {
        const student = this.studentData[studentName];
        const itemIndex = student.inventory.indexOf(itemName);
        if (itemIndex > -1) {
            student.inventory.splice(itemIndex, 1);
        }

        await updateDoc(this.dbRef, { [`studentData.${studentName}`]: student });
        this.showNotification(`Removed ${itemName} from ${studentName}'s inventory.`, 'success');
        this.openStudentProfile(studentName); // Refresh profile
    },
    openChangePasswordDialog() {
        const content = `
            <div>
                <label for="current-password" class="block mb-1 text-sm font-medium">Current Password</label>
                <input id="current-password" type="password" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
            </div>
            <div>
                <label for="new-password" class="block mb-1 text-sm font-medium">New Password (min. 6 characters)</label>
                <input id="new-password" type="password" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
            </div>
            <div>
                <label for="new-password-confirm" class="block mb-1 text-sm font-medium">Confirm New Password</label>
                <input id="new-password-confirm" type="password" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
            </div>
        `;

        this.openModal('Change Password', content, () => {
            this.handleChangePassword();
        }, 'Update Password');
    },

    async handleChangePassword() {
        const currentPassword = document.getElementById('current-password').value;
        const newPassword = document.getElementById('new-password').value;
        const newPasswordConfirm = document.getElementById('new-password-confirm').value;

        if (!currentPassword || !newPassword || !newPasswordConfirm) {
            this.showNotification("All password fields are required.", "error");
            return;
        }

        if (newPassword !== newPasswordConfirm) {
            this.showNotification("New passwords do not match.", "error");
            return;
        }

        if (newPassword.length < 6) {
            this.showNotification("New password must be at least 6 characters long.", "error");
            return;
        }

        const user = auth.currentUser;
        if (!user) {
            this.showNotification("No user is currently logged in.", "error");
            return;
        }
        
        const credential = EmailAuthProvider.credential(user.email, currentPassword);

        try {
            // Re-authenticate user to confirm their identity
            await reauthenticateWithCredential(user, credential);
            
            // If successful, update the password
            await updatePassword(user, newPassword);
            
            this.showNotification("Password updated successfully!", "success");
            this.closeModal();

        } catch (error) {
            console.error("Password change error:", error);
            let errorMessage = "Failed to change password. Please try again.";
            if (error.code === 'auth/wrong-password') {
                errorMessage = "The current password you entered is incorrect.";
            } else if (error.code === 'auth/weak-password') {
                errorMessage = "The new password is too weak.";
            }
            this.showNotification(errorMessage, "error");
        }
    },
};

window.App = App;

// =================================================================================
// DISCUSSION QUESTIONS MODULE (REVISED FOR HOMEWORK)
// =================================================================================
const DiscussionQuestions = {
    app: null,
    
    CHAPTER_QUESTIONS: {
        "chapter1": {
            "title": "The Boy Who Lived",
            "houses": {
                "Gryffindor": {
                    "traits": "Bravery, Courage, Daring",
                    "questions": [
                        "Do you think it was brave of Professor McGonagall to confront Dumbledore about leaving Harry with the Dursleys? Why or why not?",
                        "If you were in Hagrid‚Äôs place, would you have dared to fly with baby Harry on a motorcycle through the night?",
                        "Was Dumbledore brave to leave Harry in a ‚Äúnormal‚Äù family instead of keeping him in the wizarding world?",
                        "Have you ever had to make a brave choice for the good of someone else?"
                    ]
                },
                "Ravenclaw": {
                    "traits": "Wisdom, Curiosity, Intelligence",
                    "questions": [
                        "Why do you think Dumbledore trusted the Dursleys with Harry despite knowing their attitude?",
                        "What can we learn about the wizarding world from the way wizards celebrate Voldemort‚Äôs fall in this chapter?",
                        "What details in the chapter give us clues about how magical and non-magical worlds are different?",
                        "If you could ask Dumbledore one question after reading this chapter, what would it be?"
                    ]
                },
                "Hufflepuff": {
                    "traits": "Loyalty, Kindness, Fairness",
                    "questions": [
                        "How do you feel about the way the Dursleys treated Harry‚Äôs parents‚Äô memory? Was it fair?",
                        "Was it kind of Dumbledore to leave Harry with relatives, even if they didn‚Äôt want him?",
                        "How does Hagrid show loyalty to Dumbledore in this chapter?",
                        "Do you think family is about blood ties or about love and care? Why?"
                    ]
                },
                "Slytherin": {
                    "traits": "Ambition, Cunning, Resourcefulness",
                    "questions": [
                        "If you were in Dumbledore‚Äôs position, how would you make sure Harry‚Äôs identity remained secret and safe?",
                        "Do you think Voldemort‚Äôs ambition was the main reason for his downfall? Why or why not?",
                        "What do you think Petunia gained from pretending that the Potters didn‚Äôt exist?",
                        "If you had Harry‚Äôs fame from the very beginning, how would you use it to your advantage?"
                    ]
                }
            }
        }
        // Add more chapters here, e.g., "chapter2": { ... }
    },

    open() {
        const modal = document.getElementById('questions-modal');
        const modalContent = modal.querySelector('#questions-modal-content');

        const chaptersHTML = Object.entries(this.CHAPTER_QUESTIONS).map(([id, chapter]) => `
            <div class="book-card bg-[#0C1C33] p-4 rounded-lg flex items-center justify-between mb-4" onclick="DiscussionQuestions.openChapter('${id}')">
                <h4 class="font-bold text-lg text-yellow-300 cursor-pointer">${chapter.title}</h4>
                <button class="btn btn-gold">
                    <span class="mr-1">‚úçÔ∏è</span> Answer
                </button>
            </div>
        `).join('');

        modalContent.innerHTML = `
            <span class="modal-close-btn" onclick="DiscussionQuestions.close()">&times;</span>
            <h3 class="font-magic-header text-3xl text-center text-[#FFD700] mb-6">Homework Assignments</h3>
            <div class="max-h-[75vh] overflow-y-auto pr-2">
                ${chaptersHTML}
            </div>
        `;

        modal.classList.add('show');
    },

    async openChapter(chapterId) {
        if (!this.app.currentPlayerName) {
            this.app.showNotification("You must be linked to a student to answer questions.", "error");
            return;
        }
        const modalContent = document.getElementById('questions-modal-content');
        modalContent.innerHTML = `<div class="flex justify-center items-center h-48"><div class="spinner"></div></div>`;

        const chapterData = this.CHAPTER_QUESTIONS[chapterId];
        const studentAnswers = await this.loadAnswers(chapterId);

        let contentHTML = '';
        for (const houseName in chapterData.houses) {
            const houseQuestions = chapterData.houses[houseName];
            const houseInfo = this.app.HOUSES[houseName];

            const questionsHTML = houseQuestions.questions.map((q, index) => {
                const answerKey = `${houseName}_${index}`;
                const savedAnswer = studentAnswers[answerKey] || '';
                return `
                <div class="mb-4">
                    <p class="mb-2 pl-4 border-l-2 border-gray-600/50 text-gray-300">${q}</p>
                    <textarea id="answer-${chapterId}-${houseName}-${index}" class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568] text-white h-24" placeholder="Your answer...">${savedAnswer}</textarea>
                    <div class="text-right mt-1">
                        <button class="btn btn-gold text-sm" onclick="DiscussionQuestions.saveAnswer('${chapterId}', '${houseName}', ${index})">Save Answer</button>
                    </div>
                </div>
                `;
            }).join('');

            contentHTML += `
                <div class="mb-4 bg-[#0C1C33] p-5 rounded-lg border border-[#3D5568]">
                    <h4 class="font-magic-header text-2xl mb-3 flex items-center gap-3" style="color: ${houseInfo.color};">
                        <span class="text-3xl">${houseInfo.animal}</span>
                        <span>${houseName}</span>
                    </h4>
                    ${questionsHTML}
                </div>
            `;
        }

        modalContent.innerHTML = `
            <span class="modal-close-btn" onclick="DiscussionQuestions.open()">&times;</span>
            <button class="btn bg-gray-600 mb-4" onclick="DiscussionQuestions.open()">‚Üê Back to Chapters</button>
            <h3 class="font-magic-header text-3xl text-center text-[#FFD700] mb-6">${chapterData.title}</h3>
            <div class="max-h-[70vh] overflow-y-auto pr-2">
                ${contentHTML}
            </div>
        `;
    },

    async saveAnswer(chapterId, houseName, questionIndex) {
        const textarea = document.getElementById(`answer-${chapterId}-${houseName}-${questionIndex}`);
        const answerText = textarea.value.trim();
        if (!answerText) {
            this.app.showNotification("Answer cannot be empty.", "error");
            return;
        }

        if (!this.app.userId) {
            this.app.showNotification("You are not logged in.", "error");
            return;
        }

        const answerKey = `${houseName}_${questionIndex}`;
        const docRef = doc(this.app.db, "homework", this.app.userId, "answers", chapterId);

        try {
            await setDoc(docRef, { [answerKey]: answerText }, { merge: true });
            this.app.showNotification("Answer saved successfully!", "success");
        } catch (error) {
            console.error("Error saving answer:", error);
            this.app.showNotification("Could not save your answer.", "error");
        }
    },

    async loadAnswers(chapterId) {
        if (!this.app.userId) return {};
        try {
            const docRef = doc(this.app.db, "homework", this.app.userId, "answers", chapterId);
            const docSnap = await getDoc(docRef);
            return docSnap.exists() ? docSnap.data() : {};
        } catch (error) {
            console.error("Error loading answers:", error);
            return {};
        }
    },

    async showStudentHomework(studentName) {
        const student = this.app.studentData[studentName];
        if (!student || !student.authUid) {
            this.app.showNotification("This student account is not linked to a login. Cannot retrieve homework.", "error");
            return;
        }

        this.app.closeModal(); // Close the profile modal first
        const questionsModal = document.getElementById('questions-modal');
        const modalContent = questionsModal.querySelector('#questions-modal-content');
        modalContent.innerHTML = `<div class="flex justify-center items-center h-48"><div class="spinner"></div></div>`;
        questionsModal.classList.add('show');

        try {
            const answersCollectionRef = collection(this.app.db, "homework", student.authUid, "answers");
            const querySnapshot = await getDocs(answersCollectionRef);
            
            if (querySnapshot.empty) {
                modalContent.innerHTML = `
                    <span class="modal-close-btn" onclick="DiscussionQuestions.close()">&times;</span>
                    <h3 class="font-magic-header text-3xl text-center text-[#FFD700] mb-6">${studentName}'s Homework</h3>
                    <p class="text-center text-gray-400">This student has not submitted any homework yet.</p>
                `;
                return;
            }

            let homeworkHTML = '';
            for (const doc of querySnapshot.docs) {
                const chapterId = doc.id;
                const answers = doc.data();
                const chapterData = this.CHAPTER_QUESTIONS[chapterId];
                if (!chapterData) continue;

                let chapterAnswersHTML = '';
                for (const answerKey in answers) {
                    const [houseName, questionIndex] = answerKey.split('_');
                    const questionText = chapterData.houses[houseName]?.questions[questionIndex];
                    if (questionText) {
                        chapterAnswersHTML += `
                            <div class="mb-4">
                                <p class="mb-1 pl-3 border-l-2 border-gray-500 text-gray-400 italic">Q: ${questionText}</p>
                                <p class="p-2 bg-[#2A3B4D] rounded text-white">A: ${answers[answerKey]}</p>
                            </div>
                        `;
                    }
                }

                if(chapterAnswersHTML) {
                    homeworkHTML += `
                        <div class="mb-4 bg-[#0C1C33] p-5 rounded-lg border border-[#3D5568]">
                            <h4 class="font-magic-header text-2xl mb-3 text-yellow-300">${chapterData.title}</h4>
                            ${chapterAnswersHTML}
                        </div>
                    `;
                }
            }

            modalContent.innerHTML = `
                <span class="modal-close-btn" onclick="DiscussionQuestions.close()">&times;</span>
                <h3 class="font-magic-header text-3xl text-center text-[#FFD700] mb-6">${studentName}'s Homework</h3>
                <div class="max-h-[70vh] overflow-y-auto pr-2">
                    ${homeworkHTML || '<p class="text-center text-gray-400">No valid homework answers found.</p>'}
                </div>
            `;

        } catch (error) {
            console.error("Error fetching student homework:", error);
            this.app.showNotification("Could not retrieve homework.", "error");
            modalContent.innerHTML = `<p class="text-red-400">Error loading homework.</p>`;
        }
    },

    close() {
        document.getElementById('questions-modal').classList.remove('show');
    }
};
window.DiscussionQuestions = DiscussionQuestions;


// =================================================================================
// DICTIONARY MODULE
// =================================================================================
// =================================================================================
// DICTIONARY MODULE (REVISED AND FIXED)
// =================================================================================
const Dictionary = {
    app: null,
    userWords: {},

    async openDictionary() {
        if (!this.app.userId) {
            this.app.showNotification("You must be logged in to view your dictionary.", "error");
            return;
        }
        const modal = document.getElementById('dictionary-modal');
        const modalContent = modal.querySelector('#dictionary-modal-content');
        modalContent.innerHTML = `<div class="flex justify-center items-center h-48"><div class="spinner"></div></div>`;
        modal.classList.add('show');

        await this.loadUserWords();
        this.renderDictionary();
    },

    async loadUserWords() {
        if (!this.app.userId) return;
        try {
            const docRef = doc(this.app.db, "dictionaries", this.app.userId);
            const docSnap = await getDoc(docRef);
            this.userWords = docSnap.exists() ? docSnap.data().words || {} : {};
        } catch (error) {
            console.error("Error fetching dictionary:", error);
            this.app.showNotification("Could not load your dictionary.", "error");
            this.userWords = {};
        }
    },

    renderDictionary(targetId = 'dictionary-modal-content') {
        const container = document.getElementById(targetId);
        if (!container) return;

        const wordsHTML = Object.entries(this.userWords)
            .sort(([wordA], [wordB]) => wordA.localeCompare(wordB))
            .map(([word, definition]) => `
            <div class="dictionary-word-card p-4 rounded-lg flex justify-between items-start gap-4">
                <div class="flex-grow">
                    <h4 class="font-bold text-lg text-yellow-300 capitalize">${word}</h4>
                    <p class="text-gray-300 mt-1 text-sm">${definition}</p>
                </div>
                <div class="flex-shrink-0 flex flex-col gap-2">
                     <button class="btn bg-blue-600 hover:bg-blue-700 text-white text-xs p-2" onclick="Dictionary.viewOnMerriamWebster('${word}')">M-W</button>
                     <button class="btn btn-destructive text-xs p-2" onclick="Dictionary.deleteWord('${word}')">Delete</button>
                </div>
            </div>
        `).join('');

        if (targetId === 'dictionary-modal-content') {
            container.innerHTML = `
                <span class="modal-close-btn" onclick="Dictionary.closeDictionary()">&times;</span>
                <div class="flex justify-between items-center mb-4 border-b-2 border-yellow-600 pb-3">
                    <h3 class="font-magic-header text-2xl text-[#FFD700]">Your Personal Dictionary</h3>
                </div>
                <div class="space-y-3 max-h-[65vh] overflow-y-auto p-1">
                    ${Object.keys(this.userWords).length > 0 ? wordsHTML : '<p class="text-center text-gray-400 p-8">Your dictionary is empty. Click words in books to add them!</p>'}
                </div>
            `;
        } else { // For reading mode sidebar
            container.innerHTML = `
                 <h3 class="font-magic-header text-xl text-center text-[#8B4513] mb-4 border-b-2 border-[#d3c0a5] pb-2">Dictionary</h3>
                 <div class="space-y-2 overflow-y-auto flex-grow pr-2">
                    ${Object.keys(this.userWords).length > 0 ? wordsHTML : '<p class="text-center text-gray-600 p-4 text-sm">Your dictionary is empty.</p>'}
                 </div>
            `;
        }
    },

    closeDictionary() {
        document.getElementById('dictionary-modal').classList.remove('show');
    },
    
    viewOnMerriamWebster(word) {
        const url = `https://www.merriam-webster.com/dictionary/${encodeURIComponent(word)}`;
        window.open(url, '_blank');
    },

    async showDefinitionPopup(word) {
        const modal = document.getElementById('definition-popup-modal');
        const modalContent = document.getElementById('definition-popup-content');
        modal.classList.add('show');

        modalContent.innerHTML = `
            <span class="modal-close-btn" onclick="document.getElementById('definition-popup-modal').classList.remove('show')">&times;</span>
            <h3 class="font-magic-header text-2xl text-[#FFD700] mb-4 capitalize">${word}</h3>
            <div id="definition-display" class="space-y-3 max-h-[60vh] overflow-y-auto pr-2"><div class="flex justify-center p-4"><div class="spinner"></div></div></div>
            <div class="flex justify-between mt-4">
                <button class="btn bg-blue-600 text-white" onclick="Dictionary.viewOnMerriamWebster('${word}')">View on M-W</button>
                <button class="btn btn-gold" id="save-definition" disabled>Save Selected</button>
            </div>`;

        const defs = await this._fetchDefinitions(word);
        const display = modalContent.querySelector("#definition-display");
        display.innerHTML = ''; // Clear spinner

        if (defs.length > 0) {
            defs.forEach((d) => {
                const card = document.createElement('div');
                card.className = "p-3 rounded border border-[#3D5568] bg-[#182635] hover:border-yellow-300 transition cursor-pointer";
                card.innerHTML = `<p class="text-gray-200">${d.definition}</p>${d.example ? `<p class="text-gray-400 text-xs italic mt-1">${d.example}</p>` : ''}`;
                card.addEventListener('click', () => {
                    modalContent.querySelectorAll('#definition-display div.border-yellow-300').forEach(el => el.classList.remove('border-yellow-300', 'bg-[#2A3B4D]'));
                    card.classList.add('border-yellow-300', 'bg-[#2A3B4D]');
                    modalContent.querySelector("#save-definition").disabled = false;
                    modalContent.querySelector("#save-definition").onclick = () => this.saveWord(word, d.definition);
                });
                display.appendChild(card);
            });
        }
        
        const custom = document.createElement('div');
        custom.className = "p-3 rounded border border-dashed border-[#3D5568] bg-transparent mt-4";
        custom.innerHTML = `<p class="text-yellow-300 mb-2 text-sm">${defs.length > 0 ? 'Or add your own custom definition:' : 'No definitions found. Please add your own:'}</p>
            <textarea id="custom-def" class="w-full bg-[#2A3B4D] text-white p-2 rounded"></textarea>
            <div class="text-right mt-2"><button class="btn btn-gold" onclick="Dictionary.saveCustom('${word}')">Save Custom</button></div>`;
        display.appendChild(custom);
    },

    async _fetchDefinitions(word) {
        try {
            const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`);
            if (!res.ok) return [];
            const data = await res.json();
            return data.flatMap(entry => entry.meanings.flatMap(m => 
                m.definitions.map(d => ({definition: d.definition, example: d.example||""})))).slice(0, 5);
        } catch {
            return [];
        }
    },

    saveCustom(word) {
        const text = document.getElementById('custom-def')?.value.trim();
        if (!text) {
            this.app.showNotification("Please enter a definition.", "error");
            return;
        }
        this.saveWord(word, text);
    },

    async saveWord(word, definition) {
        if (!this.app.userId) return;
        const cleanedWord = word.toLowerCase();

        if (this.userWords[cleanedWord]) {
            this.app.showNotification(`"${word}" is already in your dictionary.`, "info");
            document.getElementById('definition-popup-modal').classList.remove('show');
            return;
        }

        const docRef = doc(this.app.db, "dictionaries", this.app.userId);
        try {
            await setDoc(docRef, { words: { [cleanedWord]: definition } }, { merge: true });
            this.userWords[cleanedWord] = definition;
            this.app.playSound(this.app.SOUNDS.add_word);
            this.app.showNotification(`Added "${word}" to your dictionary!`, "success");
            document.getElementById('definition-popup-modal').classList.remove('show');
            this.refreshAllViews();
        } catch (e) {
            console.error("Firestore save error:", e);
            this.app.showNotification("Error: Could not save word.", "error");
        }
    },

    async deleteWord(word) {
        if (!this.app.userId) return;
        const docRef = doc(this.app.db, "dictionaries", this.app.userId);
        try {
            await updateDoc(docRef, { [`words.${word}`]: deleteField() });
            delete this.userWords[word];
            this.app.showNotification(`Removed "${word}" from your dictionary.`, "success");
            this.refreshAllViews();
        } catch (e) {
            console.error("Firestore delete error:", e);
            this.app.showNotification("Error: Could not delete word.", "error");
        }
    },
    
    refreshAllViews() {
        if (document.getElementById('dictionary-modal').classList.contains('show')) {
            this.renderDictionary();
        }
        if (document.getElementById('reading-mode-container').classList.contains('reading-mode-active')) {
            Dictionary.renderDictionary('reading-mode-dictionary');
        }
    }
};
window.Dictionary = Dictionary;

// =================================================================================
// LIBRARY MODULE
// =================================================================================
const Library = {
    app: null,
    readerSettings: {
        fontFamily: "'IM Fell English', serif"
    },
    currentBookId: null,
    currentChapterId: null,

    async openLibrary() {
        const modal = document.getElementById('library-modal');
        const modalContent = modal.querySelector('#library-modal-content');
        modalContent.innerHTML = `<h3 class="font-magic-header text-2xl text-[#FFD700] mb-4 text-center">Loading Library...</h3>`;
        modal.classList.add('show');
        this.app.playSound(this.app.SOUNDS.open_book);

        try {
            const booksRef = collection(this.app.db, 'books');
            const querySnapshot = await getDocs(booksRef);
            const books = [];
            querySnapshot.forEach(doc => {
                books.push({ id: doc.id, ...doc.data() });
            });

            const booksHTML = books.map(book => {
                const editButtonHTML = this.app.isAdmin ?
                    `<button class="btn bg-[#3D5568] text-white text-sm ml-2" onclick="Library.toggleEditMode(this, 'book', '${book.id}')">‚úèÔ∏è</button>` : '';
                
                return `
                <div class="book-card bg-[#0C1C33] p-4 rounded-lg flex items-center justify-between mb-4">
                    <div class="flex-grow">
                        <h4 class="font-bold text-lg" data-book-id="${book.id}" style="color: #E0E0E0;">${book.title || book.id}</h4>
                        <p class="text-sm text-gray-400">${book.author || 'J. K. Rowling'}</p>
                    </div>
                    <div class="flex items-center">
                        <button class="btn btn-gold" onclick="Library.openBook('${book.id}')">
                            <span class="mr-1">üìñ</span> Read
                        </button>
                        ${editButtonHTML}
                    </div>
                </div>`;
            }).join('');

            modalContent.innerHTML = `
                <span class="modal-close-btn" onclick="document.getElementById('library-modal').classList.remove('show')">&times;</span>
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-magic-header text-2xl text-[#FFD700]">The Library</h3>
                </div>
                <div class="space-y-4">
                    ${books.length > 0 ? booksHTML : '<p class="text-center text-gray-400 py-4">The library is currently empty.</p>'}
                </div>
            `;
        } catch (error) {
            console.error("Error fetching books:", error);
            this.app.showNotification("Could not open the library.", "error");
            modalContent.innerHTML = `<p class="text-center text-red-400">Error loading library. Check Firestore security rules.</p>
            <button class="btn btn-gold mt-4" onclick="document.getElementById('library-modal').classList.remove('show')">Close</button>`;
        }
    },

    async openBook(bookId) {
        this.currentBookId = bookId;
        document.getElementById('library-modal').classList.remove('show');
        const readerModal = document.getElementById('reader-modal');
        const readerContent = readerModal.querySelector('#reader-modal-content');
        
        const bookRef = doc(this.app.db, 'books', bookId);
        const bookSnap = await getDoc(bookRef);
        const bookTitle = bookSnap.exists() ? bookSnap.data().title : 'Book Not Found';

        readerContent.innerHTML = `<h3 class="font-magic-header text-2xl text-[#FFD700] mb-4 text-center">Opening ${bookTitle}...</h3>`;
        readerModal.classList.add('show');

        try {
            const chaptersRef = collection(this.app.db, 'books', bookId, 'chapters');
            const querySnapshot = await getDocs(chaptersRef);
            const chapters = [];
            querySnapshot.forEach(doc => {
                chapters.push({ id: doc.id, ...doc.data() });
            });

            chapters.sort((a, b) => {
                const numA = parseInt(a.id.match(/\d+/g)?.[0] || 0);
                const numB = parseInt(b.id.match(/\d+/g)?.[0] || 0);
                return numA - numB;
            });

            const chaptersHTML = chapters.map(chap => {
                 const editButtonHTML = this.app.isAdmin ?
                    `<button class="btn bg-[#3D5568] text-white text-xs p-1 ml-2" onclick="Library.toggleEditMode(this, 'chapter', '${bookId}', '${chap.id}')">‚úèÔ∏è</button>` : '';

                return `<li class="chapter-item p-2 rounded hover:bg-[#2A3B4D] cursor-pointer">
                    <div class="flex items-center justify-between">
                        <a href="#" class="flex-grow" data-chapter-id="${chap.id}" onclick="Library.loadChapter('${bookId}', '${chap.id}')" style="color: #E0E0E0;">${chap.title || chap.id}</a>
                        ${editButtonHTML}
                    </div>
                </li>`;
            }).join('');

            const savedSettings = localStorage.getItem('readerSettings');
            if (savedSettings) {
                this.readerSettings = JSON.parse(savedSettings);
            }

            readerContent.innerHTML = `
                <span class="modal-close-btn" onclick="Library.closeReader()">&times;</span>
                <div class="flex justify-between items-center mb-4 border-b border-[#3D5568] pb-4">
                    <h3 class="font-magic-header text-2xl text-[#FFD700]">${bookTitle}</h3>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-4 gap-8">
                    <div class="md:col-span-1">
                        <h4 class="font-bold mb-2 text-white">Chapters</h4>
                        <ul id="chapter-list" class="space-y-1 max-h-[70vh] overflow-y-auto">${chaptersHTML}</ul>
                    </div>
                    <div class="md:col-span-3 flex flex-col">
                        <div id="reader-toolbar" class="reader-toolbar flex items-center gap-2 mb-4 p-3">
                            <button id="reading-mode-btn" class="toolbar-btn flex items-center">
                                <span class="mr-1">üìñ</span> Reading mode
                            </button>
                            <select id="font-family-select" class="toolbar-btn bg-[#2A3B4D] text-white p-1 rounded">
                                <option value="'IM Fell English', serif" class="font-option" style="font-family: 'IM Fell English', serif;">IM Fell English (Default)</option>
                                <option value="'Inter', sans-serif" class="font-option" style="font-family: 'Inter', sans-serif;">Inter</option>
                                <option value="'Merriweather', serif" class="font-option" style="font-family: 'Merriweather', serif;">Merriweather</option>
                                <option value="'Lora', serif" class="font-option" style="font-family: 'Lora', serif;">Lora</option>
                                <option value="'Playfair Display', serif" class="font-option" style="font-family: 'Playfair Display', serif;">Playfair Display</option>
                                <option value="'EB Garamond', serif" class="font-option" style="font-family: 'EB Garamond', serif;">EB Garamond</option>
                                <option value="'Roboto Slab', serif" class="font-option" style="font-family: 'Roboto Slab', serif;">Roboto Slab</option>
                                <option value="'Lato', sans-serif" class="font-option" style="font-family: 'Lato', sans-serif;">Lato</option>
                                <option value="'Open Sans', sans-serif" class="font-option" style="font-family: 'Open Sans', sans-serif;">Open Sans</option>
                                <option value="'Cormorant Garamond', serif" class="font-option" style="font-family: 'Cormorant Garamond', serif;">Cormorant Garamond</option>
                                <option value="'Alegreya', serif" class="font-option" style="font-family: 'Alegreya', serif;">Alegreya</option>
                                <option value="'Uncial Antiqua', cursive" class="font-option" style="font-family: 'Uncial Antiqua', cursive;">Uncial Antiqua</option>
                            </select>
                        </div>
                        <div id="reader-content-container" class="flex-grow p-6 rounded-lg overflow-y-auto parchment">
                            <div id="reader-content">
                                <p class="text-center">Select a chapter to begin reading.</p>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            readerContent.querySelector('#reading-mode-btn').addEventListener('click', () => this.enterReadingMode());
            readerContent.querySelector('#font-family-select').addEventListener('change', (e) => this.changeFontFamily(e.target.value));
            
            readerContent.querySelector('#font-family-select').value = this.readerSettings.fontFamily;
            
            if (chapters.length > 0) {
                this.loadChapter(bookId, chapters[0].id);
            }

        } catch (error) {
            console.error(`Error fetching chapters for ${bookId}:`, error);
            this.app.showNotification("Could not open book.", "error");
            readerContent.innerHTML = `<p>Error loading book. Please try again later.</p>`;
        }
    },

    closeReader() {
        const readerModal = document.getElementById('reader-modal');
        readerModal.classList.remove('show');
        this.openLibrary();
    },

    async loadChapter(bookId, chapterId) {
        this.currentBookId = bookId;
        this.currentChapterId = chapterId;
        const contentContainer = document.getElementById('reader-content');
        if (!contentContainer) return;
        contentContainer.innerHTML = `<p class="text-center py-8">Loading chapter...</p>`;
        this.app.playSound(this.app.SOUNDS.turn_page);

        document.querySelectorAll('#chapter-list .chapter-item').forEach(el => el.classList.remove('active'));
        const activeLink = document.querySelector(`#chapter-list li a[onclick*="'${chapterId}'"]`);
        if(activeLink) {
            activeLink.parentElement.parentElement.classList.add('active');
        }

        try {
            const chapterRef = doc(this.app.db, 'books', bookId, 'chapters', chapterId);
            const docSnap = await getDoc(chapterRef);

        if (docSnap.exists()) {
            const chapterData = docSnap.data();
            const formattedContent = this.formatChapterContent(chapterData);
            
            contentContainer.innerHTML = `
                <h4 class="text-xl font-bold mb-4 text-center">${chapterData.title || chapterId}</h4>
                ${formattedContent}
            `;
            
            this.applyReaderSettings();
            this.addWordClickListener(contentContainer);

        } else {
            contentContainer.innerHTML = `<p class="text-center py-8">Chapter content not found.</p>`;
        }
        } catch (error) {
            console.error(`Error loading chapter ${chapterId}:`, error);
            contentContainer.innerHTML = `<p class="text-center py-8">Error loading chapter content.</p>`;
            this.app.showNotification("Failed to load chapter.", "error");
        }
    },

    formatChapterContent(chapterData) {
        const chapterText = chapterData.content || chapterData.text;
        if (chapterText && typeof chapterText === 'string') {
            return chapterText
                .split('\n')
                .filter(p => p.trim() !== '')
                .map(p => {
                    const words = p.trim().split(' ').map(word => `<span class="clickable-word">${word}</span>`).join(' ');
                    return `<p>${words}</p>`;
                })
                .join('');
        }
        return '<p class="text-center">This chapter appears to be empty.</p>';
    },

    addWordClickListener(container) {
        container.addEventListener('click', (e) => {
            if (e.target.classList.contains('clickable-word')) {
                let selectedText = e.target.textContent.trim().toLowerCase();
                selectedText = selectedText.replace(/^[^\w-]+|[^\w-]+$/g, ''); 

                if (selectedText && selectedText.length > 1 && !selectedText.includes(' ')) {
                    Dictionary.showDefinitionPopup(selectedText);
                }
            }
        });
    },
    
    applyReaderSettings() {
        const contentElements = [
            document.getElementById('reader-content'),
            document.getElementById('reading-mode-content')
        ];
        contentElements.forEach(content => {
            if (content) {
                content.style.fontFamily = this.readerSettings.fontFamily;
            }
        });
    },
    
    changeFontFamily(fontFamily) {
        this.readerSettings.fontFamily = fontFamily;
        this.applyReaderSettings();
        this.saveReaderSettings();
    },
    
    saveReaderSettings() {
        localStorage.setItem('readerSettings', JSON.stringify(this.readerSettings));
    },
    
    async enterReadingMode() {
        const readerModal = document.getElementById('reader-modal');
        const readingModeContainer = document.getElementById('reading-mode-container');
        const readingModeContent = document.getElementById('reading-mode-content');
        const originalContent = document.getElementById('reader-content').innerHTML;

        if (!readingModeContainer || !readingModeContent) return;

        // Copy content and apply settings
        readingModeContent.innerHTML = originalContent;
        this.applyReaderSettings();
        this.addWordClickListener(readingModeContent);

        // Show reading mode and hide modal
        readingModeContainer.classList.remove('hidden');
        readingModeContainer.classList.add('reading-mode-active');
        readerModal.classList.remove('show');
        
        // Load and render dictionary
        await Dictionary.loadUserWords();
        Dictionary.renderDictionary('reading-mode-dictionary');

        // Setup exit button
        document.getElementById('exit-reading-mode-btn').onclick = () => this.exitReadingMode();
    },

    exitReadingMode() {
        const readingModeContainer = document.getElementById('reading-mode-container');
        if (!readingModeContainer) return;

        readingModeContainer.classList.add('hidden');
        readingModeContainer.classList.remove('reading-mode-active');
        
        // Re-open the book in the standard modal view
        if (this.currentBookId) {
            this.openBook(this.currentBookId).then(() => {
                if (this.currentChapterId) {
                    this.loadChapter(this.currentBookId, this.currentChapterId);
                }
            });
        }
    },
    
    toggleEditMode(button, type, id1, id2 = null) {
        let titleElement;
        if (type === 'book') {
            titleElement = document.querySelector(`h4[data-book-id="${id1}"]`);
        } else { // chapter
            titleElement = document.querySelector(`a[data-chapter-id="${id2}"]`);
        }

        const isEditing = titleElement.isContentEditable;

        if (isEditing) {
            titleElement.contentEditable = false;
            button.textContent = '‚úèÔ∏è';
            titleElement.style.outline = 'none';
            titleElement.style.backgroundColor = 'transparent';
            if (type === 'book') titleElement.style.color = '#E0E0E0'; 
            else if(!titleElement.parentElement.parentElement.classList.contains('active')) titleElement.style.color = '#E0E0E0';

            const newTitle = titleElement.textContent.trim();
            this.saveTitle(type, id1, id2, newTitle);
        } else {
            titleElement.contentEditable = true;
            button.textContent = 'üíæ'; // Save icon
            titleElement.style.color = '#5a4429'; 
            titleElement.focus();
            
            const range = document.createRange();
            range.selectNodeContents(titleElement);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }
    },

    async saveTitle(type, id1, id2, newTitle) {
        if (!newTitle) {
            this.app.showNotification("Title cannot be empty.", "error");
            if (type === 'book') this.openLibrary();
            else this.openBook(id1);
            return;
        }

        let docRef;
        if (type === 'book') {
            docRef = doc(this.app.db, 'books', id1);
        } else { // chapter
            docRef = doc(this.app.db, 'books', id1, 'chapters', id2);
        }

        try {
            await updateDoc(docRef, { title: newTitle });
            this.app.showNotification("Title updated successfully!", "success");
        } catch (error) {
            console.error("Error updating title:", error);
            this.app.showNotification("Error updating title.", "error");
            if (type === 'book') this.openLibrary();
            else this.openBook(id1);
        }
    }
};
window.Library = Library;


// =================================================================================
// MAGIC SHOP MODULE
// =================================================================================
const Shop = {
    app: null,

    open() {
        const studentName = this.app.currentPlayerName;
        if (!studentName) {
             this.app.showNotification("You must be linked to a student profile to shop. An admin can link your account.", "error");
             return;
        }
        
        const student = this.app.studentData[studentName];

        const itemsHTML = Object.entries(this.app.SHOP_ITEMS).map(([name, item]) => `
            <div class="flex items-center justify-between p-3 bg-[#0C1C33] rounded-lg border border-[#3D5568]">
                <div class="flex items-center gap-4">
                    <span class="text-3xl">${item.icon}</span>
                    <div>
                        <p class="font-bold">${name}</p>
                        <p class="text-sm text-gray-400">${item.desc}</p>
                    </div>
                </div>
                <div class="text-right">
                    <p class="text-lg font-bold text-[#FFD700]">${item.cost} points</p>
                    <button class="btn btn-gold text-sm mt-1" onclick="Shop.buyItem('${studentName}', '${name}')" 
                        ${student.points < item.cost ? 'disabled' : ''}>
                        Buy
                    </button>
                </div>
            </div>
        `).join('');

        const content = `
            <p class="text-right mb-2">Your Points: <span class="font-bold text-xl text-[#FFD700]">${student.points}</span></p>
            <div class="space-y-3 max-h-96 overflow-y-auto p-1">${itemsHTML}</div>
        `;

        this.app.openModal('Diagon Alley Emporium', content, null);
    },

    buyItem(studentName, itemName) {
        this.app.requestPurchase(studentName, itemName);
    }
};
window.Shop = Shop;

// =================================================================================
// DUELING CLUB MODULE
// =================================================================================
const DuelingClub = {
    app: null,
    duelist1: null,
    duelist2: null,
    roundCount: 0,
    gameOver: false,
    isProcessing: false,
    isPaused: false,
    isFastMode: false,
    turnTimeout: null,
    currentCaster: null,
    currentTarget: null,
    WORDS_TO_HIGHLIGHT: ['damage', 'shield', 'heals', 'restores', 'victorious', 'fails', 'attempts', 'defensive', 'offensive', 'success', 'failure', 'blocks', 'broken', 'fades', 'backfires', 'potion', 'lucky'],

    DESCRIPTIONS: {
        cast: [
            "{caster} raises their wand and shouts, '{spellName}!'",
            "With a flick of their wrist, {caster} casts {spellName}!",
            "{caster} focuses their energy, unleashing {spellName} at {target}."
        ],
        hit: [
            "The spell strikes {target}, who staggers back, taking {damage} damage!",
            "A direct hit! {target} is blasted by the spell for {damage} damage.",
            "The curse finds its mark, inflicting {damage} damage upon {target}."
        ],
        miss: [
            "{caster}'s spell goes wide, missing {target} completely!",
            "{target} deftly dodges the incoming {spellName}!",
            "The spell fizzles out, failing to reach its target."
        ],
        crit_fail: [
            "A catastrophic failure! The spell {backfires} and explodes in {caster}'s face!",
            "The magic is unstable! {caster}'s own {spellName} turns against them!",
            "Disaster! The wand backfires, hitting {caster} with their own spell!"
        ],
        shield_block: [
            "{target}'s shield flares, absorbing {blocked} damage from the attack!",
            "The {spellName} impacts harmlessly against {target}'s magical barrier, blocking {blocked} damage."
        ],
        shield_break: [
            "The force of the spell is too much! {target}'s shield shatters!",
            "With a loud crack, the defensive barrier around {target} is {broken}!"
        ],
        heal: [
            "A warm glow surrounds {caster}, restoring {healedAmount} HP.",
            "{caster} mends their wounds with magic, healing for {healedAmount} HP."
        ],
        potion_heal: [
            "{caster} quickly drinks a potion, restoring {healedAmount} HP.",
            "The Wiggenweld Potion soothes {caster}'s injuries, healing for {healedAmount} HP."
        ],
        potion_mp: [
            "{caster} consumes a Focus Draught, restoring {restoredMp} MP.",
            "Energy flows back into {caster} as they drink the draught, restoring {restoredMp} MP."
        ]
    },

    getDuelLogEntry(type, context) {
        const templates = this.DESCRIPTIONS[type];
        if (!templates) return "An unknown action occurred.";
        
        let entry = templates[Math.floor(Math.random() * templates.length)];
        
        for (const key in context) {
            entry = entry.replace(new RegExp(`\\{${key}\\}`, 'g'), context[key]);
        }

        return entry;
    },

    openDuelSetup() {
        if (Object.keys(this.app.studentData).length < 2) {
            this.app.showNotification("Need at least two students to start a duel.", "error");
            return;
        }

        const studentOptions = Object.keys(this.app.studentData).sort();
        const content = `
            <span class="modal-close-btn" onclick="DuelingClub.closeDuelModal()">&times;</span>
            <div class="text-center mb-4">
                 <h3 class="font-magic-header text-3xl text-[#FFD700]">The Dueling Club</h3>
                 <p>Choose two students and a duel mode.</p>
            </div>
            <div class="flex justify-around items-center mb-6">
                <select id="duelist1-select" class="bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
                    ${studentOptions.map(s => `<option value="${s}">${s}</option>`).join('')}
                </select>
                <span class="font-magic-title text-2xl text-[#FFD700]">VS</span>
                <select id="duelist2-select" class="bg-[#2A3B4D] rounded p-2 border border-[#3D5568]">
                    ${studentOptions.map((s, i) => `<option value="${s}" ${i === 1 ? 'selected' : ''}>${s}</option>`).join('')}
                </select>
            </div>
            <div class="flex justify-center gap-4 mt-6">
                 <button id="start-duel-btn" class="btn btn-gold text-lg">üìú Begin Duel!</button>
                 <button id="start-fast-duel-btn" class="btn bg-blue-600 text-white text-lg">‚ö° Fast Duel</button>
            </div>
        `;
        
        const modal = document.getElementById('duel-modal');
        const modalContent = modal.querySelector('#duel-modal-content');
        modalContent.innerHTML = content;
        
        modal.classList.add('show');
        modal.querySelector('#start-duel-btn').addEventListener('click', () => this.startDuel(false));
        modal.querySelector('#start-fast-duel-btn').addEventListener('click', () => this.startDuel(true));
    },

    closeDuelModal() {
        clearTimeout(this.turnTimeout);
        document.getElementById('duel-modal').classList.remove('show');
        this.duelist1 = null; this.duelist2 = null;
    },

    startDuel(isFastMode = false) {
        const d1Name = document.getElementById('duelist1-select').value;
        const d2Name = document.getElementById('duelist2-select').value;

        if (d1Name === d2Name) {
            this.app.showNotification("A duelist cannot fight themself!", "error");
            return;
        }
        
        this.duelPlaySound(this.app.SOUNDS.duel_start);

        this.duelist1 = this.createDuelistState(d1Name);
        this.duelist2 = this.createDuelistState(d2Name);
        this.roundCount = 0;
        this.gameOver = false;
        this.isProcessing = false;
        this.isPaused = false;
        this.isFastMode = isFastMode;
        this.currentCaster = this.duelist1;
        this.currentTarget = this.duelist2;
        
        this.renderDuelArena();
        this.log(`A duel begins between ${d1Name} and ${d2Name}!`);
        
        if (this.isFastMode) {
            this.continueFastDuel();
        } else {
            this.log(`It's ${this.currentCaster.name}'s turn.`, 'yellow');
        }
    },
    
    createDuelistState(name) {
        const student = this.app.studentData[name];
        // Deep copy of inventory to avoid modifying original data during duel
        const inventoryCopy = student.inventory ? JSON.parse(JSON.stringify(student.inventory)) : [];
        return {
            name: name,
            house: this.app.currentAssignments[name] || 'Unsorted',
            hp: student.hp, maxHp: this.app.DEFAULT_HP,
            mp: student.mp, maxMp: this.app.DEFAULT_MP,
            shield: null, statusEffects: {},
            inventory: inventoryCopy,
            effects: {}
        };
    },

    renderDuelArena() {
        let controlsHTML = '';
        if (this.isFastMode) {
            controlsHTML = `<button id="pause-resume-btn" class="btn btn-gold">Pause</button>`;
        } else {
            controlsHTML = `<button id="make-move-btn" class="btn btn-gold">Make a Move</button>`;
        }

        const content = `
            <span class="modal-close-btn" onclick="DuelingClub.closeDuelModal()">&times;</span>
            <div id="duel-arena" class="p-4 rounded-lg">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                    <div id="duelist1-panel" class="duelist-panel bg-[#0C1C33] p-4 rounded-lg border border-gray-600"></div>
                    <div class="bg-[#0C1C33] p-4 rounded-lg border border-gray-600 flex flex-col justify-center items-center">
                        <h4 class="font-magic-header text-xl text-center text-[#FFD700] mb-2">üìú Duel Log üìú</h4>
                        <div id="duel-log" class="h-64 w-full overflow-y-auto text-sm space-y-2 pr-2 mb-4"></div>
                        <div id="d20-dice"><div id="d20-cube"><div id="d20-face-display" class="d20-face">20</div></div></div>
                        <p id="roll-target-text" class="text-sm text-gray-400 mt-2 h-4"></p>
                    </div>
                    <div id="duelist2-panel" class="duelist-panel bg-[#0C1C33] p-4 rounded-lg border border-gray-600"></div>
                </div>
                <div id="duel-controls" class="text-center mt-4 h-10">
                    ${controlsHTML}
                </div>
            </div>
        `;
        const modalContent = document.getElementById('duel-modal-content');
        modalContent.innerHTML = content;
        
        if (this.isFastMode) {
            modalContent.querySelector('#pause-resume-btn').addEventListener('click', () => this.togglePause());
        } else {
            modalContent.querySelector('#make-move-btn').addEventListener('click', () => this.makeMove());
        }

        this.updateDuelUI();
    },

    makeMove() {
        if (this.isProcessing || this.gameOver) return;
        this.isProcessing = true;
        this.updateDuelUI(); // This will disable the button
        this.processTurn();
    },

    togglePause() {
        this.isPaused = !this.isPaused;
        const btn = document.getElementById('pause-resume-btn');
        if (this.isPaused) {
            btn.textContent = 'Resume';
            this.log('Duel paused.', 'yellow');
            clearTimeout(this.turnTimeout);
        } else {
            btn.textContent = 'Pause';
            this.log('Duel resuming...', 'yellow');
            this.continueFastDuel();
        }
    },
    
    updateDuelUI() {
        if (!this.duelist1) return;
        const renderPanel = (duelist, panelId) => {
            const panel = document.getElementById(panelId);
            if (!panel) return;
            const house = this.app.HOUSES[duelist.house] || {};
            const statusText = Object.keys(duelist.statusEffects).length > 0 ?
                Object.keys(duelist.statusEffects).map(k => `${k}(${duelist.statusEffects[k].duration})`).join(', ') : 'Normal';

            const inventoryText = duelist.inventory.map(itemName => {
                const item = this.app.SHOP_ITEMS[itemName];
                return `<span title="${item.desc}">${item.icon}</span>`;
            }).join(' ');
            
            const felixText = (duelist.effects.guaranteed_hit && duelist.effects.guaranteed_hit.duration > 0) ? 
                `<p class="text-sm text-yellow-300">‚ú® Lucky (${duelist.effects.guaranteed_hit.duration})</p>` : '';

            let panelHTML = `
                <h4 class="font-bold text-lg" style="color:${house.color}">${house.animal} ${duelist.name}</h4>
                <div class="my-2">
                    <p>HP: ${duelist.hp} / ${duelist.maxHp}</p>
                    <div class="progress-bar"><div class="progress-bar-inner bg-red-500" style="width:${(duelist.hp/duelist.maxHp)*100}%"></div></div>
                </div>
                <div class="my-2">
                    <p>MP: ${duelist.mp} / ${duelist.maxMp}</p>
                    <div class="progress-bar"><div class="progress-bar-inner bg-blue-500" style="width:${(duelist.mp/duelist.maxMp)*100}%"></div></div>
                </div>
                <p class="text-sm">Status: <span class="text-yellow-400">${statusText}</span></p>
                ${duelist.shield ? `<p class="text-sm text-cyan-400">Shield: ${duelist.shield.name} (${duelist.shield.strength})</p>` : ''}
                ${felixText}
                <p class="text-sm mt-1">Inventory: ${inventoryText || 'Empty'}</p>
            `;
            if (this.currentCaster === duelist && !this.isProcessing && !this.gameOver && !this.isFastMode && duelist.inventory.length > 0) {
                panelHTML += `<div class="mt-2">
                    <button class="btn text-sm bg-green-600 text-white" onclick="DuelingClub.openItemMenu()">Use Item</button>
                </div>`;
            }
            panel.innerHTML = panelHTML;
        };
        renderPanel(this.duelist1, 'duelist1-panel');
        renderPanel(this.duelist2, 'duelist2-panel');

        if (!this.isFastMode) {
            const makeMoveBtn = document.getElementById('make-move-btn');
            if (makeMoveBtn) {
                makeMoveBtn.disabled = this.isProcessing || this.gameOver;
            }
        }
    },
    
    highlightWords(text) {
        let newText = text;
        this.WORDS_TO_HIGHLIGHT.forEach(word => {
            const regex = new RegExp(`\\b(${word})\\b`, 'gi');
            newText = newText.replace(regex, `<span class="learn-word">$1</span>`);
        });
        return newText;
    },

    log(message, color = '#E0E0E0') {
        const logContainer = document.getElementById('duel-log');
        if (!logContainer) return;
        const entry = document.createElement('p');
        entry.innerHTML = this.highlightWords(message);
        entry.style.color = color;
        logContainer.appendChild(entry);
        logContainer.scrollTop = logContainer.scrollHeight;
    },
    
    continueFastDuel() {
        if (this.gameOver || this.isPaused) return;
        
        this.isProcessing = true;
        this.processTurn();
    },

    processTurn() {
        if (this.gameOver) return;

        const caster = this.currentCaster;
        const target = this.currentTarget;

        document.querySelectorAll('.duelist-panel').forEach(p => p.classList.remove('active-turn'));
        document.getElementById(caster === this.duelist1 ? 'duelist1-panel' : 'duelist2-panel').classList.add('active-turn');

        if (caster === this.duelist1) {
            this.roundCount++;
            this.log(`\n--- Round ${this.roundCount} ---`, '#C0C0C0');
            this.tickEffects(this.duelist1);
            this.tickEffects(this.duelist2);
            if (this.checkGameOver()) { this.isProcessing = false; return; }
        }
        
        this.updateDuelUI(); 

        const executeAction = () => {
            // In Fast Mode, AI considers using a potion
            if (this.isFastMode && this.considerUsingPotion()) {
                if (this.checkGameOver()) { this.isProcessing = false; return; }
                this.endTurn();
                return;
            }

            const spellName = this.chooseSpell(caster);
            const spell = this.app.SPELL_DETAILS[spellName];
            
            this.log(this.getDuelLogEntry('cast', { caster: caster.name, target: target.name, spellName }));
            
            const rollTargetText = document.getElementById('roll-target-text');
            if(rollTargetText) rollTargetText.textContent = `Roll Target: ${spell.accuracy}+`;
            
            // *** NEW: Check for Felix Felicis effect ***
            if (caster.effects.guaranteed_hit && caster.effects.guaranteed_hit.duration > 0) {
                this.log(`${caster.name} is under the effect of Felix Felicis!`, '#FFD700');
                caster.effects.guaranteed_hit.duration--;
                
                // Animate the dice to show 20
                this.animateD20(() => {
                    this.log(`d20 Roll: 20. Critical Success!`, '#FFD700');
                    this.executeSpell(caster, target, spellName);
                    
                    if (caster.effects.guaranteed_hit.duration <= 0) {
                        delete caster.effects.guaranteed_hit;
                        this.log('The luck of Felix Felicis wears off.', 'cyan');
                    }
                    
                    if (this.checkGameOver()) { this.isProcessing = false; return; }
                    this.endTurn();
                }, 21, 20); // accuracy > 20 to force success style, force result to 20
                return; // Skip normal roll
            }
            
            // Normal roll if not lucky
            this.animateD20((rollResult) => {
                const success = rollResult >= spell.accuracy;
                const critFail = rollResult === 1;

                if (critFail) {
                    this.log(this.getDuelLogEntry('crit_fail', { caster: caster.name, spellName }), '#f472b6');
                    this.duelPlaySound(this.app.SOUNDS.crit_fail_sound);
                    if (spell.type.includes('offensive')) {
                        this.executeSpell(caster, caster, spellName); // Target self
                    } else {
                        this.log(`The ${spellName} spell erupts in harmless sparks.`, 'gray');
                    }
                } else if (success) {
                    this.log(`d20 Roll: ${rollResult}. Success!`, '#34D399');
                    this.executeSpell(caster, target, spellName);
                } else {
                    this.log(`d20 Roll: ${rollResult}. Failure!`, '#F87171');
                    this.log(this.getDuelLogEntry('miss', { caster: caster.name, target: target.name, spellName }), 'gray');
                    this.duelPlaySound(this.app.SOUNDS.duel_miss);
                }
                
                if (this.checkGameOver()) { this.isProcessing = false; return; }
                this.endTurn();
            }, spell.accuracy);
        };

        const delay = this.isFastMode ? 200 : 1500;
        this.turnTimeout = setTimeout(executeAction, delay);
    },

    endTurn() {
        this.updateDuelUI();

        if (this.checkGameOver()) {
            this.isProcessing = false;
            return;
        }

        const nextCaster = this.currentTarget;
        const nextTarget = this.currentCaster;
        this.currentCaster = nextCaster;
        this.currentTarget = nextTarget;
        
        const isEndOfRound = this.currentTarget === this.duelist1;
        if (isEndOfRound) {
            this.currentCaster.mp = Math.min(this.currentCaster.maxMp, this.currentCaster.mp + 5);
            this.currentTarget.mp = Math.min(this.currentTarget.maxMp, this.currentTarget.mp + 5);
            this.log('End of round. Duelists recover some energy.');
            this.updateDuelUI();
        }

        if (this.isFastMode) {
            const delay = isEndOfRound ? 1000 : 500;
            this.turnTimeout = setTimeout(() => this.continueFastDuel(), delay);
        } else {
            this.isProcessing = false;
            this.updateDuelUI();
            this.log(`It's now ${this.currentCaster.name}'s turn.`, 'yellow');
        }
    },

    animateD20(callback, accuracy, forceResult = null) {
        this.duelPlaySound(this.app.SOUNDS.dice_roll, 0.05);
        const cube = document.getElementById('d20-cube');
        const face = document.getElementById('d20-face-display');
        if (!cube || !face) { if (callback) callback(forceResult || Math.ceil(Math.random() * 20)); return; }

        face.classList.remove('success', 'failure', 'crit-fail', 'crit-success');
        cube.classList.add('rolling');

        let rollInterval;
        if (!this.isFastMode) {
            rollInterval = setInterval(() => {
                if (this.isPaused) return;
                face.textContent = Math.ceil(Math.random() * 20);
            }, 50);
        }

        const animationDuration = this.isFastMode ? 100 : 1000;
        setTimeout(() => {
            if(rollInterval) clearInterval(rollInterval);
            cube.classList.remove('rolling');
            const finalResult = forceResult !== null ? forceResult : Math.ceil(Math.random() * 20);
            face.textContent = finalResult;
            if (finalResult === 20) {
                face.classList.add('crit-success');
            } else if (finalResult === 1) {
                face.classList.add('crit-fail');
            } else if (finalResult >= accuracy) {
                face.classList.add('success');
            } else {
                face.classList.add('failure');
            }
            if (callback) callback(finalResult);
        }, animationDuration);
    },

    tickEffects(duelist) {
        for (const effect in duelist.statusEffects) {
            duelist.statusEffects[effect].duration--;
            if (duelist.statusEffects[effect].duration <= 0) {
                this.log(`${duelist.name} is no longer affected by ${effect}.`, 'cyan');
                delete duelist.statusEffects[effect];
            }
        }
        if (duelist.shield) {
            duelist.shield.duration--;
            if (duelist.shield.duration <= 0) {
                this.log(`${duelist.shield.name} on ${duelist.name} fades.`, 'cyan');
                duelist.shield = null;
            }
        }
        this.updateDuelUI();
    },

    chooseSpell(duelist) {
        const availableSpells = Object.keys(this.app.SPELL_DETAILS).filter(s => {
            const spell = this.app.SPELL_DETAILS[s];
            return spell.mp <= duelist.mp && !duelist.statusEffects.silence;
        });
        if (availableSpells.length === 0) return "Struggle"; 
        
        // Let the Felix Felicis check in processTurn handle the powerful spell logic
        return availableSpells[Math.floor(Math.random() * availableSpells.length)];
    },

    executeSpell(caster, target, spellName) {
        const spell = this.app.SPELL_DETAILS[spellName];
        if (!spell || caster.mp < spell.mp) {
            this.log(`${caster.name} lacks the mana!`, 'gray');
            return;
        }
        
        caster.mp -= spell.mp;
        this.duelPlaySound(this.app.SOUNDS.spell_cast_ui, 0.05);

        if (spell.type === 'heal') {
            const healAmount = spell.base_heal;
            caster.hp = Math.min(caster.maxHp, caster.hp + healAmount);
            this.log(this.getDuelLogEntry('heal', {caster: caster.name, healedAmount: healAmount}), 'lightgreen');
        } else if (spell.type === 'shield') {
            caster.shield = { name: spellName, strength: spell.strength, duration: spell.duration };
            this.log(`${caster.name} creates a defensive shield, ${spellName}!`, 'cyan');
        } else if (spell.type.includes('offensive')) {
            let damage = spell.base_dmg;
            let finalDamage = damage;
            
            if (target.shield) {
                const blocked = Math.min(target.shield.strength, damage);
                finalDamage -= blocked;
                target.shield.strength -= blocked;
                this.log(this.getDuelLogEntry('shield_block', {target: target.name, spellName, blocked}), 'cyan');

                if (target.shield.strength <= 0) {
                    this.log(this.getDuelLogEntry('shield_break', {target: target.name}), 'red');
                    target.shield = null;
                    this.duelPlaySound(this.app.SOUNDS.shield_break);
                } else {
                    this.duelPlaySound(this.app.SOUNDS.duel_block);
                }
            }
            
            if (finalDamage > 0) {
                target.hp = Math.max(0, target.hp - finalDamage);
                this.log(this.getDuelLogEntry('hit', {target: target.name, damage: finalDamage}), 'red');
                this.duelPlaySound(this.app.SOUNDS.duel_hit);
            }
        }
        this.updateDuelUI();
    },
    
    checkGameOver() {
        if (this.gameOver) return true;
        let winner = null, loser = null;
        if (this.duelist1.hp <= 0) {
            winner = this.duelist2;
            loser = this.duelist1;
        } else if (this.duelist2.hp <= 0) {
            winner = this.duelist1;
            loser = this.duelist2;
        }

        if (winner) {
            this.gameOver = true;
            this.isProcessing = false;
            clearTimeout(this.turnTimeout);
            this.log(`--- DUEL OVER! ---`, '#FFD700');
            this.log(`${winner.name} of ${winner.house} is victorious!`, '#FFD700');
            this.duelPlaySound(this.app.SOUNDS.celebration);
            
            if (this.app.isAdmin) {
                this.log('Both duelists have been fully healed.', 'lightgreen');
                this.app.HOUSES[winner.house].points += 10;
                this.log(`${winner.house} is awarded 10 points!`, '#FFD700');

                this.app.studentData[winner.name].hp = this.app.DEFAULT_HP;
                this.app.studentData[winner.name].mp = this.app.DEFAULT_MP;
                
                this.app.studentData[loser.name].hp = this.app.DEFAULT_HP;
                this.app.studentData[loser.name].mp = this.app.DEFAULT_MP;
                
                this.app.addHistory(`Dueling Club: ${winner.name} defeated ${loser.name}.`, `Winner awarded 10 points. Health restored.`);
                this.app.saveProgress();
            }

            const controls = document.getElementById('duel-controls');
            if (controls) {
                controls.innerHTML = `<p class="text-xl font-bold text-green-400">${winner.name} wins!</p>`;
            }
            this.turnTimeout = setTimeout(() => this.closeDuelModal(), 4000);
            return true;
        }
        return false;
    },

    openItemMenu() {
        if (this.isPaused || this.isProcessing) return;
        this.isProcessing = true; // Pause turn progression
        
        const caster = this.currentCaster;
        const itemsHTML = caster.inventory.map(itemName => {
            const item = this.app.SHOP_ITEMS[itemName];
            return `<button class="btn btn-gold w-full text-left p-2" onclick="DuelingClub.useItem('${itemName}')">
                <span class="text-xl">${item.icon}</span> ${itemName}
            </button>`;
        }).join('');

        const logContainer = document.getElementById('duel-log');
        const itemMenu = document.createElement('div');
        itemMenu.id = 'item-menu';
        itemMenu.className = 'p-2 border border-yellow-400 rounded bg-black/50';
        itemMenu.innerHTML = `
            <h5 class="text-center font-bold mb-2">Use Item</h5>
            <div class="space-y-2">${itemsHTML || '<p class="text-gray-400">No items.</p>'}</div>
            <button class="btn bg-gray-600 w-full mt-2" onclick="DuelingClub.closeItemMenu()">Cancel</button>
        `;
        logContainer.appendChild(itemMenu);
        logContainer.scrollTop = logContainer.scrollHeight;
        this.updateDuelUI();
    },

    closeItemMenu() {
        const menu = document.getElementById('item-menu');
        if (menu) menu.remove();
        this.log('Decided not to use an item.');
        this.isProcessing = false;
        this.updateDuelUI();
    },

    useItem(itemName) {
        const menu = document.getElementById('item-menu');
        if (menu) menu.remove();

        const caster = this.currentCaster;
        this.executeItem(caster, itemName);
        
        this.endTurn();
    },
    
    executeItem(caster, itemName) {
        const item = this.app.SHOP_ITEMS[itemName];
        const itemIndex = caster.inventory.indexOf(itemName);

        if (itemIndex === -1) {
            this.log("Item not found!", 'red');
            return false;
        }

        this.log(`${caster.name} uses ${itemName}!`, 'lightblue');
        this.duelPlaySound(this.app.SOUNDS.potion_use);
        caster.inventory.splice(itemIndex, 1);

        const effect = item.effect;
        switch (effect.type) {
            case 'heal':
                const healedAmount = Math.min(caster.maxHp - caster.hp, effect.amount);
                caster.hp += healedAmount;
                this.log(this.getDuelLogEntry('potion_heal', {caster: caster.name, healedAmount: healedAmount}), 'lightgreen');
                break;
            case 'mp_restore':
                const restoredMp = Math.min(caster.maxMp - caster.mp, effect.amount);
                caster.mp += restoredMp;
                this.log(this.getDuelLogEntry('potion_mp', {caster: caster.name, restoredMp: restoredMp}), 'lightblue');
                break;
            case 'guaranteed_hit':
                caster.effects.guaranteed_hit = { duration: effect.duration };
                this.log(`The next ${effect.duration} spell rolls are now guaranteed critical successes!`, '#FFD700');
                break;
            case 'add_shield':
                caster.shield = { name: effect.name, strength: effect.strength, duration: effect.duration };
                this.log(`${caster.name} is now protected by a shield of ${effect.strength} strength!`, 'cyan');
                break;
        }
        return true;
    },

    considerUsingPotion() {
        const caster = this.currentCaster;
        // Heal if HP is below 40%
        if (caster.hp < caster.maxHp * 0.4 && caster.inventory.includes("Wiggenweld Potion")) {
            return this.executeItem(caster, "Wiggenweld Potion");
        }
        // Restore MP if below 15
        if (caster.mp < 15 && caster.inventory.includes("Focus Draught")) {
            return this.executeItem(caster, "Focus Draught");
        }
        // Use shield if caster has no shield and target is healthy
        if (!caster.shield && this.currentTarget.hp > this.currentTarget.maxHp * 0.5 && caster.inventory.includes("Shielding Brew")) {
            return this.executeItem(caster, "Shielding Brew");
        }
        return false; // No item was used
    },

    duelPlaySound(...args) {
        if (!this.isFastMode) {
            this.app.playSound(...args);
        }
    }
};

window.DuelingClub = DuelingClub;

// =================================================================================
// QUIDDITCH D&D MODULE (UPGRADED GM AI)
// =================================================================================
const Quidditch = {
    app: null,
    isProcessing: false,
    chatHistory: [],
    gameState: {},
    GROQ_API_KEY: null,

    openGame() {
        const modal = document.getElementById('quidditch-modal');
        const modalContent = document.getElementById('quidditch-modal-content');
        modal.classList.add('show');
        
        this.GROQ_API_KEY = localStorage.getItem('groqApiKey');

        if (this.GROQ_API_KEY) {
            this.renderGameUI(modalContent);
            this.startGame();
        } else {
            this.renderApiKeySetup(modalContent);
        }
    },

    renderApiKeySetup(container) {
        const currentKey = this.GROQ_API_KEY || '';
        container.innerHTML = `
            <span class="modal-close-btn" onclick="Quidditch.closeGame()">&times;</span>
            <div class="flex flex-col items-center justify-center h-full">
                <h3 class="font-magic-header text-3xl text-center text-[#FFD700]">Quidditch Commentary Setup</h3>
                <p class="text-center my-4 text-gray-300">To power the magical commentary box, please provide your Groq API key. This is a free key you can get from the Groq website.</p>
                <div class="w-full max-w-md">
                    <label for="groq-api-key" class="block mb-2 text-sm font-medium text-gray-300">Your Groq API Key</label>
                    <input type="password" id="groq-api-key" placeholder="gsk_..." class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568]" value="${currentKey}">
                    <button class="btn btn-gold w-full mt-4" onclick="Quidditch.saveApiKey()">Save API Key</button>
                    <a href="https://console.groq.com/keys" target="_blank" class="block text-center mt-2 text-sm text-[#FFD700] hover:underline">Get a Groq API Key</a>
                </div>
            </div>
        `;
    },

    saveApiKey() {
        const keyInput = document.getElementById('groq-api-key');
        const key = keyInput.value.trim();
        if (key) {
            localStorage.setItem('groqApiKey', key);
            this.GROQ_API_KEY = key;
            this.app.showNotification("API Key saved!", "success");
            this.openGame();
        } else {
            this.app.showNotification("Please enter a valid API key.", "error");
        }
    },

    renderGameUI(container) {
        container.innerHTML = `
            <span class="modal-close-btn" onclick="Quidditch.closeGame()">&times;</span>
            <div class="flex flex-col h-[85vh]">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="font-magic-header text-3xl text-center text-[#FFD700]">Quidditch Match</h3>
                    <div class="flex items-center gap-2">
                         <div id="quidditch-scoreboard" class="font-bold text-xl text-white"></div>
                         <button class="btn bg-gray-600 text-xs p-2" onclick="Quidditch.renderApiKeySetup(document.getElementById('quidditch-modal-content'))" title="Change API Key">‚öôÔ∏è</button>
                    </div>
                </div>
                
                <!-- Chat/Narrative Display -->
                <div id="quidditch-chat-display" class="flex-grow bg-[#0C1C33] p-4 rounded-lg border border-[#3D5568] mb-4 overflow-y-auto flex flex-col">
                    <!-- Messages will be injected here -->
                </div>
                
                <!-- Player Controls -->
                <div class="flex-shrink-0 grid grid-cols-1 md:grid-cols-3 gap-4">
                    <!-- Action Buttons -->
                    <div class="md:col-span-1 space-y-2">
                        <button class="btn btn-gold w-full" onclick="Quidditch.performAction('Try to score with the Quaffle')">Score with Quaffle</button>
                        <button class="btn btn-gold w-full" onclick="Quidditch.performAction('Search for the Golden Snitch')">Search for Snitch</button>
                        <button class="btn btn-gold w-full" onclick="Quidditch.performAction('Hit a Bludger at an opponent')">Hit a Bludger</button>
                        <button class="btn btn-gold w-full" onclick="Quidditch.performAction('Defend the goalposts')">Defend Goals</button>
                    </div>
                    
                    <!-- Custom Action & Dice -->
                    <div class="md:col-span-2 bg-[#1A2B3C] p-4 rounded-lg border border-[#3D5568] flex flex-col justify-between">
                        <input type="text" id="quidditch-custom-action" placeholder="Or type your own action..." class="w-full bg-[#2A3B4D] rounded p-2 border border-[#3D5568] mb-2">
                        <div class="flex items-center justify-between">
                            <div id="quidditch-dice-container">
                                <div id="quidditch-dice">
                                    <div id="quidditch-dice-face" class="quidditch-dice-face">20</div>
                                </div>
                            </div>
                            <button id="quidditch-roll-btn" class="btn bg-green-600 text-white text-lg flex-grow ml-4" onclick="Quidditch.performAction()">Roll d20 & Act!</button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        // Add event listener for Enter key
        container.querySelector('#quidditch-custom-action').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault(); // Prevent default Enter behavior
                this.performAction();
            }
        });
    },

    closeGame() {
        document.getElementById('quidditch-modal').classList.remove('show');
    },

    startGame() {
        this.isProcessing = false;
        this.gameState = {
            score: { player: 0, opponent: 0 },
            possession: 'neutral',
            snitchSpotted: false,
            turn: 0,
            weather: 'clear'
        };
        
        const systemPrompt = `You are the "Quidditch Commentary Box AI," controlling a duo of commentators: Lee, who is very biased and excited for the player's team, and Gwenog, a calm professional ex-player. You are also the game master. Your task is to:
1. Narrate the outcome of the player's action based on their roll and the current game state. The commentary should be a back-and-forth between Lee and Gwenog. Be exciting and descriptive.
2. Introduce random events. A Bludger attack, a foul, a change in weather, a brilliant move by a teammate, etc.
3. Update the game state. At the VERY END of your commentary, you MUST include ONE special tag on a NEW LINE to update the game.

**Game State Tags (CHOOSE ONLY ONE PER RESPONSE):**
- [SCORE PLAYER 10]
- [SCORE OPPONENT 10]
- [POSSESSION PLAYER]
- [POSSESSION OPPONENT]
- [SNITCH SPOTTED]
- [SNITCH CAUGHT PLAYER]
- [EVENT BLUDGER_ATTACK]
- [NO_CHANGE]

**CRITICAL RULES:**
1. Do NOT answer any non-Quidditch questions. If the user asks something unrelated to the match, you MUST redirect them back to the game. Example: "Lee: No time for that, look out! A Bludger is heading your way! What do you do?"
2. Do NOT include the "Current Game State" JSON object in your response. Your response should ONLY be the commentary from Lee and Gwenog, followed by a single game state tag on a new line.

**Example Interaction:**
Player Action: "Try to score with the Quaffle", Roll: 18
Game State: { "score": { "player": 10, "opponent": 10 }, "possession": "player" }
Your Response:
Lee: "And they're off! A brilliant dodge past the opponent's Chaser! This is it!"
Gwenog: "Textbook form. They see the opening, they take the shot... GOAL! A fantastic play, putting them ahead."
[SCORE PLAYER 10]`;

        const openingLine = "Lee: Welcome back to the Hogwarts Pitch! The players are taking their positions, and the energy here is electric! \nGwenog: It's a fine day for a match, Lee. Let's see which team has the edge today. \nLee: The whistle blows! What's your first move?";

        this.chatHistory = [
            { role: "system", content: systemPrompt },
            { role: "assistant", content: openingLine }
        ];
        
        const chatDisplay = document.getElementById('quidditch-chat-display');
        if(chatDisplay) chatDisplay.innerHTML = '';
        this.addMessage(openingLine, "ai");
        this.updateScoreboard();
    },

    updateScoreboard() {
        const scoreboard = document.getElementById('quidditch-scoreboard');
        if (scoreboard) {
            scoreboard.innerHTML = `YOU: ${this.gameState.score.player} - OPP: ${this.gameState.score.opponent}`;
        }
    },

    addMessage(text, sender, rollResult = null) {
        const chatDisplay = document.getElementById('quidditch-chat-display');
        if (!chatDisplay) return;

        const messageDiv = document.createElement('div');
        messageDiv.classList.add('quidditch-chat-message');
        
        let content = ``;
        if (sender === 'user') {
            messageDiv.classList.add('user-message');
            content = `<p class="font-bold">You (Rolled ${rollResult}):</p><p>${text}</p>`;
        } else if (sender === 'ai') {
            messageDiv.classList.add('ai-message');
            // Make commentator names bold
            let formattedText = text.replace(/^(Lee:)/gm, '<strong class="text-yellow-300">Lee:</strong>');
            formattedText = formattedText.replace(/^(Gwenog:)/gm, '<strong class="text-cyan-300">Gwenog:</strong>');
            content = `<div>${formattedText.replace(/\n/g, '<br>')}</div>`;
        } else { // 'event'
             messageDiv.classList.add('event-message');
             content = `<p>${text}</p>`;
        }
        
        messageDiv.innerHTML = content;
        chatDisplay.appendChild(messageDiv);
        chatDisplay.scrollTop = chatDisplay.scrollHeight;
    },

    async performAction(predefinedAction = null) {
        if (this.isProcessing) return;
        this.isProcessing = true;
        this.toggleControls(false);

        const customActionInput = document.getElementById('quidditch-custom-action');
        const actionText = predefinedAction || customActionInput.value.trim();

        if (!actionText) {
            this.app.showNotification("You must specify an action!", "error");
            this.isProcessing = false;
            this.toggleControls(true);
            return;
        }

        const roll = await this.animateDice();
        this.addMessage(actionText, 'user', roll);
        customActionInput.value = '';

        this.getAIResponse(actionText, roll);
    },

    async getAIResponse(action, roll) {
        this.addMessage("The commentators watch intently...", "event");
        this.gameState.turn++;

        const currentActionPrompt = `Player Action: "${action}"\nd20 Roll: ${roll}\nCurrent Game State: ${JSON.stringify(this.gameState)}`;
        
        const messagesForAPI = [...this.chatHistory];
        messagesForAPI.push({ role: "user", content: currentActionPrompt });

        try {
            if (!this.GROQ_API_KEY) {
                 throw new Error("Groq API key is not set. Please set it up in the Quidditch modal.");
            }
            
            const apiUrl = 'https://api.groq.com/openai/v1/chat/completions';

            const payload = {
                model: "llama-3.3-70b-versatile",
                messages: messagesForAPI
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.GROQ_API_KEY}`
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                console.error("Groq API Error:", errorData);
                throw new Error(`API request failed: ${errorData.error.message}`);
            }

            const result = await response.json();
            
            if (result.choices && result.choices[0]?.message?.content) {
                const rawText = result.choices[0].message.content;
                
                this.chatHistory.push({ role: "user", content: currentActionPrompt });
                this.processAIResponse(rawText);
            } else {
                console.error("Invalid API Response:", result);
                throw new Error("API response was empty or malformed.");
            }

        } catch (error) {
            console.error("Error calling Groq API:", error);
            this.addMessage(`The magic connecting us to the commentary box seems to have failed. Error: ${error.message}. Please check the API key and console.`, "event");
        } finally {
            this.isProcessing = false;
            this.toggleControls(true);
        }
    },

    processAIResponse(rawText) {
        const tagMatch = rawText.match(/\[(.*?)\]/);
        let commentary = rawText;
        let tag = '[NO_CHANGE]';

        if (tagMatch) {
            commentary = rawText.replace(tagMatch[0], '').trim();
            tag = tagMatch[0];
        }

        this.addMessage(commentary, 'ai');
        this.chatHistory.push({ role: "assistant", content: rawText });

        // Update game state based on the tag
        const tagParts = tag.replace(/[\[\]]/g, '').split(' ');
        const command = tagParts[0];
        const subject = tagParts[1];
        const value = parseInt(tagParts[2], 10);

        switch(command) {
            case 'SCORE':
                if (subject === 'PLAYER') this.gameState.score.player += value;
                if (subject === 'OPPONENT') this.gameState.score.opponent += value;
                this.updateScoreboard();
                break;
            case 'POSSESSION':
                this.gameState.possession = subject.toLowerCase();
                break;
            case 'SNITCH':
                if (subject === 'SPOTTED') this.gameState.snitchSpotted = true;
                if (subject === 'CAUGHT' && subject === 'PLAYER') {
                    this.gameState.score.player += 150;
                    this.updateScoreboard();
                    this.addMessage("YOU'VE CAUGHT THE SNITCH! YOU WIN!", "event");
                    this.isProcessing = true; // End game
                    this.toggleControls(false);
                }
                break;
            case 'EVENT':
                // Could add specific logic for events like BLUDGER_ATTACK here
                break;
        }
    },

    animateDice() {
        return new Promise(resolve => {
            this.app.playSound(this.app.SOUNDS.dice_roll, 0.05);
            const dice = document.getElementById('quidditch-dice');
            const face = document.getElementById('quidditch-dice-face');
            if (!dice || !face) { resolve(Math.ceil(Math.random() * 20)); return; }

            dice.classList.add('rolling');
            
            const rollInterval = setInterval(() => {
                face.textContent = Math.ceil(Math.random() * 20);
            }, 60);

            setTimeout(() => {
                clearInterval(rollInterval);
                dice.classList.remove('rolling');
                const finalResult = Math.ceil(Math.random() * 20);
                face.textContent = finalResult;
                resolve(finalResult);
            }, 1000);
        });
    },

    toggleControls(enabled) {
        const rollBtn = document.getElementById('quidditch-roll-btn');
        const actionBtns = document.querySelectorAll('#quidditch-modal .btn');
        const input = document.getElementById('quidditch-custom-action');

        if (enabled) {
            rollBtn.disabled = false;
            rollBtn.innerHTML = 'Roll d20 & Act!';
            actionBtns.forEach(btn => btn.disabled = false);
            input.disabled = false;
        } else {
            rollBtn.disabled = true;
            rollBtn.innerHTML = '<div class="spinner mx-auto"></div>';
            actionBtns.forEach(btn => btn.disabled = true);
            input.disabled = true;
        }
    }
};
window.Quidditch = Quidditch;

// =================================================================================
// DICTIONARY TRAINING MODULE (IMPLEMENTED)
// =================================================================================
const DictionaryTraining = {
    app: null,
    gameActive: false,
    currentWords: [],
    score: 0,
    currentIndex: 0,
    timer: null,
    
    TRAINING_MODES: {
        'word-translation': { name: 'Word-Definition', icon: '‚ÜîÔ∏è', desc: 'Choose the correct word for the given definition.', minWords: 4 },
        'word-constructor': { name: 'Word Constructor', icon: 'üõ†Ô∏è', desc: 'Assemble the word from a scramble of letters.', minWords: 1 },
        'sprint': { name: 'Sprint', icon: 'üèÉ', desc: 'Quickly decide if the word and definition match.', minWords: 2 },
        'word-cards': { name: 'Word Cards', icon: 'üÉè', desc: 'Review words with classic flashcards.', minWords: 1 },
        'word-sprint': { name: 'Word Sprint (Brainstorm)', icon: 'üí®', desc: 'Type the correct word for the definition before time runs out.', minWords: 1 }
    },

    async openHub() {
        if (!this.app.userId) {
            this.app.showNotification("You must be logged in to train words.", "error");
            return;
        }
        await Dictionary.loadUserWords(); // Ensure we have the latest words
        const wordCount = Object.keys(Dictionary.userWords).length;

        const modal = document.getElementById('dictionary-training-modal');
        const modalContent = document.getElementById('dictionary-training-content');
        
        const hubHTML = Object.entries(this.TRAINING_MODES).map(([key, mode]) => {
            const disabled = wordCount < mode.minWords;
            return `
                <div class="training-hub-card p-4 rounded-lg flex items-center gap-4 ${disabled ? 'opacity-50 cursor-not-allowed' : ''}" 
                     onclick="${disabled ? '' : `DictionaryTraining.startGame('${key}')`}">
                    <div class="text-5xl">${mode.icon}</div>
                    <div>
                        <h4 class="font-bold text-lg text-yellow-300">${mode.name}</h4>
                        <p class="text-sm text-gray-300">${mode.desc}</p>
                        ${disabled ? `<p class="text-xs text-red-400">Requires at least ${mode.minWords} words in your dictionary.</p>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        modalContent.innerHTML = `
            <span class="modal-close-btn" onclick="document.getElementById('dictionary-training-modal').classList.remove('show')">&times;</span>
            <h3 class="font-magic-header text-3xl text-center text-[#FFD700] mb-2">Dictionary Training Grounds</h3>
            <p class="text-center text-gray-400 mb-6">You have ${wordCount} words to practice. Choose your training method!</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 max-h-[60vh] overflow-y-auto pr-2">
                ${hubHTML}
            </div>
        `;
        modal.classList.add('show');
    },

    startGame(gameType) {
        this.gameActive = true;
        this.score = 0;
        this.currentIndex = 0;
        this.currentWords = this.getWordsForTraining(20); // Limit to 20 words per session
        
        if (this.currentWords.length < this.TRAINING_MODES[gameType].minWords) {
            this.app.showNotification("Not enough words for this training.", "error");
            return;
        }
        
        document.getElementById('dictionary-training-modal').classList.remove('show');
        const gameModal = document.getElementById('training-game-modal');
        gameModal.classList.add('show');
        
        const gameContent = document.getElementById('training-game-content');
        gameContent.innerHTML = `<div class="flex justify-center items-center h-48"><div class="spinner"></div></div>`;
        
        switch(gameType) {
            case 'word-translation': this.setupWordTranslation(); break;
            case 'word-constructor': this.setupWordConstructor(); break;
            case 'sprint': this.setupSprint(); break;
            case 'word-cards': this.setupWordCards(); break;
            case 'word-sprint': this.setupWordSprint(); break;
        }
    },

    closeGame() {
        this.gameActive = false;
        if (this.timer) clearInterval(this.timer);
        document.getElementById('training-game-modal').classList.remove('show');
        this.openHub();
    },
    
    // ==== Word Translation ====
    setupWordTranslation() {
        if (this.currentIndex >= this.currentWords.length) {
            this.showGameResults();
            return;
        }
        const gameContent = document.getElementById('training-game-content');
        const currentWord = this.currentWords[this.currentIndex];
        
        const allWords = Object.keys(Dictionary.userWords);
        let options = [currentWord.word];
        while(options.length < 4) {
            const randomWord = allWords[Math.floor(Math.random() * allWords.length)];
            if (!options.includes(randomWord)) {
                options.push(randomWord);
            }
        }
        this.shuffleArray(options);
        
        const optionsHTML = options.map(opt => `
            <button class="training-game-option p-4 rounded-lg text-lg capitalize" onclick="DictionaryTraining.checkWordTranslation(this, '${opt}', '${currentWord.word}')">${opt}</button>
        `).join('');
        
        gameContent.innerHTML = `
            <span class="modal-close-btn" onclick="DictionaryTraining.closeGame()">&times;</span>
            <div class="text-right text-sm mb-2">${this.currentIndex + 1} / ${this.currentWords.length} | Score: ${this.score}</div>
            <p class="text-center text-gray-300 mb-4">Choose the word for this definition:</p>
            <div class="bg-[#0C1C33] p-4 rounded-lg text-center min-h-[100px] flex items-center justify-center mb-6">
                <p>"${currentWord.definition}"</p>
            </div>
            <div id="translation-options" class="grid grid-cols-2 gap-4">
                ${optionsHTML}
            </div>
        `;
    },

    checkWordTranslation(button, selectedWord, correctWord) {
        document.querySelectorAll('#translation-options button').forEach(b => b.disabled = true);
        if (selectedWord === correctWord) {
            this.score++;
            button.classList.add('correct');
            this.app.playSound(this.app.SOUNDS.correct_answer);
        } else {
            button.classList.add('incorrect');
            this.app.playSound(this.app.SOUNDS.incorrect_answer);
            // Highlight the correct one
            document.querySelectorAll('#translation-options button').forEach(b => {
                if (b.textContent === correctWord) b.classList.add('correct');
            });
        }
        this.currentIndex++;
        setTimeout(() => this.setupWordTranslation(), 1500);
    },

    // ==== Word Constructor ====
    setupWordConstructor() {
        if (this.currentIndex >= this.currentWords.length) {
            this.showGameResults();
            return;
        }
        const gameContent = document.getElementById('training-game-content');
        const currentWord = this.currentWords[this.currentIndex];
        const scrambled = currentWord.word.split('').sort(() => 0.5 - Math.random());
        
        const lettersHTML = scrambled.map((letter, index) => `
            <button class="letter-tile bg-[#2A3B4D] p-3 rounded text-xl font-bold" data-index="${index}" onclick="DictionaryTraining.constructorAddLetter(this, '${letter}')">${letter}</button>
        `).join('');

        gameContent.innerHTML = `
            <span class="modal-close-btn" onclick="DictionaryTraining.closeGame()">&times;</span>
            <div class="text-right text-sm mb-2">${this.currentIndex + 1} / ${this.currentWords.length} | Score: ${this.score}</div>
            <div class="bg-[#0C1C33] p-4 rounded-lg text-center min-h-[80px] flex items-center justify-center mb-4">
                <p>"${currentWord.definition}"</p>
            </div>
            <div id="constructor-answer" class="bg-[#0C1C33] p-4 rounded-lg h-16 mb-4 text-2xl tracking-widest text-center"></div>
            <div id="constructor-letters" class="flex flex-wrap justify-center gap-2 mb-4">
                ${lettersHTML}
            </div>
            <div class="flex justify-center gap-4">
                <button class="btn bg-gray-600" onclick="DictionaryTraining.constructorClear()">Clear</button>
                <button class="btn btn-gold" onclick="DictionaryTraining.checkWordConstructor()">Submit</button>
            </div>
        `;
    },

    constructorAddLetter(button, letter) {
        const answerDiv = document.getElementById('constructor-answer');
        answerDiv.textContent += letter;
        button.disabled = true;
        button.style.opacity = '0.3';
    },

    constructorClear() {
        document.getElementById('constructor-answer').textContent = '';
        document.querySelectorAll('#constructor-letters button').forEach(b => {
            b.disabled = false;
            b.style.opacity = '1';
        });
    },

    checkWordConstructor() {
        const answerDiv = document.getElementById('constructor-answer');
        const userAnswer = answerDiv.textContent;
        const correctWord = this.currentWords[this.currentIndex].word;

        if (userAnswer === correctWord) {
            this.score++;
            answerDiv.classList.add('bg-green-800');
            this.app.playSound(this.app.SOUNDS.correct_answer);
        } else {
            answerDiv.classList.add('bg-red-800');
            this.app.playSound(this.app.SOUNDS.incorrect_answer);
            answerDiv.textContent = correctWord; // Show correct answer
        }
        this.currentIndex++;
        setTimeout(() => this.setupWordConstructor(), 1500);
    },

    // ==== Sprint ====
    setupSprint() {
        if (this.currentIndex >= this.currentWords.length) {
            this.showGameResults();
            return;
        }
        const gameContent = document.getElementById('training-game-content');
        const currentWord = this.currentWords[this.currentIndex];
        
        const shouldMatch = Math.random() > 0.5;
        let definitionToShow = '';
        if (shouldMatch) {
            definitionToShow = currentWord.definition;
        } else {
            const otherWords = this.currentWords.filter(w => w.word !== currentWord.word);
            definitionToShow = otherWords[Math.floor(Math.random() * otherWords.length)].definition;
        }

        gameContent.innerHTML = `
            <span class="modal-close-btn" onclick="DictionaryTraining.closeGame()">&times;</span>
            <div class="text-right text-sm mb-2">${this.currentIndex + 1} / ${this.currentWords.length} | Score: ${this.score}</div>
            <div class="text-center">
                <p class="text-4xl font-bold capitalize mb-4 text-yellow-300">${currentWord.word}</p>
                <div class="bg-[#0C1C33] p-4 rounded-lg min-h-[100px] flex items-center justify-center mb-6">
                    <p>"${definitionToShow}"</p>
                </div>
                <div id="sprint-feedback" class="h-8 mb-4"></div>
                <div class="flex justify-center gap-4">
                    <button class="btn btn-destructive text-lg px-8" onclick="DictionaryTraining.checkSprint(false, ${shouldMatch})">‚ùå Don't Match</button>
                    <button class="btn bg-green-600 text-white text-lg px-8" onclick="DictionaryTraining.checkSprint(true, ${shouldMatch})">‚úîÔ∏è Match</button>
                </div>
            </div>
        `;
    },

    checkSprint(userChoice, isMatch) {
        const feedbackDiv = document.getElementById('sprint-feedback');
        if (userChoice === isMatch) {
            this.score++;
            feedbackDiv.innerHTML = `<p class="text-green-400 font-bold text-2xl">Correct!</p>`;
            this.app.playSound(this.app.SOUNDS.correct_answer);
        } else {
            feedbackDiv.innerHTML = `<p class="text-red-400 font-bold text-2xl">Incorrect!</p>`;
            this.app.playSound(this.app.SOUNDS.incorrect_answer);
        }
        this.currentIndex++;
        setTimeout(() => this.setupSprint(), 800);
    },

    // ==== Word Cards ====
    setupWordCards() {
        const gameContent = document.getElementById('training-game-content');
        if (this.currentIndex < 0) this.currentIndex = 0;
        if (this.currentIndex >= this.currentWords.length) this.currentIndex = this.currentWords.length - 1;

        const currentWord = this.currentWords[this.currentIndex];

        gameContent.innerHTML = `
            <span class="modal-close-btn" onclick="DictionaryTraining.closeGame()">&times;</span>
            <div class="text-right text-sm mb-2">${this.currentIndex + 1} / ${this.currentWords.length}</div>
            <div class="word-card h-64" onclick="this.classList.toggle('is-flipped')">
                <div class="word-card-inner">
                    <div class="word-card-face word-card-front">
                        <h3 class="text-4xl font-bold capitalize">${currentWord.word}</h3>
                    </div>
                    <div class="word-card-face word-card-back">
                        <p class="text-center">${currentWord.definition}</p>
                    </div>
                </div>
            </div>
            <div class="flex justify-between items-center mt-6">
                <button class="btn bg-gray-600" onclick="DictionaryTraining.currentIndex--; DictionaryTraining.setupWordCards()">‚Üê Previous</button>
                <button class="btn btn-gold" onclick="DictionaryTraining.closeGame()">Finish Review</button>
                <button class="btn bg-gray-600" onclick="DictionaryTraining.currentIndex++; DictionaryTraining.setupWordCards()">Next ‚Üí</button>
            </div>
        `;
    },

    // ==== Word Sprint (Brainstorm) ====
    setupWordSprint() {
        if (this.timer) clearInterval(this.timer);
        if (this.currentIndex >= this.currentWords.length) {
            this.showGameResults();
            return;
        }
        const gameContent = document.getElementById('training-game-content');
        const currentWord = this.currentWords[this.currentIndex];
        let timeLeft = 15;

        gameContent.innerHTML = `
            <span class="modal-close-btn" onclick="DictionaryTraining.closeGame()">&times;</span>
            <div class="flex justify-between items-center mb-2">
                <div class="text-sm">${this.currentIndex + 1} / ${this.currentWords.length} | Score: ${this.score}</div>
                <div id="sprint-timer" class="font-bold text-lg text-yellow-300">${timeLeft}s</div>
            </div>
            <div class="bg-[#0C1C33] p-4 rounded-lg text-center min-h-[100px] flex items-center justify-center mb-4">
                <p>"${currentWord.definition}"</p>
            </div>
            <input type="text" id="word-sprint-input" class="w-full bg-[#2A3B4D] rounded p-3 text-center text-xl border border-[#3D5568]" autocomplete="off">
            <div id="word-sprint-feedback" class="h-8 mt-4 text-center"></div>
        `;

        const input = document.getElementById('word-sprint-input');
        input.focus();
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                this.checkWordSprint();
            }
        });

        const timerDiv = document.getElementById('sprint-timer');
        this.timer = setInterval(() => {
            timeLeft--;
            timerDiv.textContent = `${timeLeft}s`;
            if (timeLeft <= 5) timerDiv.classList.add('text-red-500');
            if (timeLeft <= 0) {
                this.checkWordSprint();
            }
        }, 1000);
    },

    checkWordSprint() {
        if (this.timer) clearInterval(this.timer);
        const input = document.getElementById('word-sprint-input');
        input.disabled = true;
        const userAnswer = input.value.trim().toLowerCase();
        const correctWord = this.currentWords[this.currentIndex].word.toLowerCase();
        const feedbackDiv = document.getElementById('word-sprint-feedback');

        if (userAnswer === correctWord) {
            this.score++;
            feedbackDiv.innerHTML = `<p class="text-green-400 font-bold text-2xl">Correct!</p>`;
            this.app.playSound(this.app.SOUNDS.correct_answer);
        } else {
            feedbackDiv.innerHTML = `<p class="text-red-400 font-bold text-2xl">Incorrect! The word was: <span class="capitalize">${correctWord}</span></p>`;
            this.app.playSound(this.app.SOUNDS.incorrect_answer);
        }
        this.currentIndex++;
        setTimeout(() => this.setupWordSprint(), 2000);
    },
    
    // ==== UTILITY FUNCTIONS ====
    getWordsForTraining(count) {
        const allWords = Object.entries(Dictionary.userWords).map(([word, definition]) => ({ word, definition }));
        this.shuffleArray(allWords);
        return allWords.slice(0, count);
    },

    shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    },
    
    showGameResults() {
        const gameContent = document.getElementById('training-game-content');
        const totalQuestions = this.currentWords.length;
        const accuracy = totalQuestions > 0 ? Math.round((this.score / totalQuestions) * 100) : 0;
        gameContent.innerHTML = `
            <span class="modal-close-btn" onclick="DictionaryTraining.closeGame()">&times;</span>
            <h3 class="font-magic-header text-2xl text-center text-[#FFD700] mb-4">Training Complete!</h3>
            <p class="text-center text-5xl font-bold mb-4">${this.score}/${totalQuestions}</p>
            <p class="text-center text-2xl text-yellow-300 mb-6">Accuracy: ${accuracy}%</p>
            <div class="flex justify-center gap-4">
                <button class="btn btn-gold" onclick="DictionaryTraining.closeGame()">Back to Hub</button>
            </div>
        `;
        if (accuracy > 80) {
            this.app.playSound(this.app.SOUNDS.celebration);
        }
    }
};
window.DictionaryTraining = DictionaryTraining;

</script>
</body>
</html>
